
Points-to for call02


// Points To IN:
// p -> *NULL_POINTER* , MAY
// p -> _p_5[0] , MAY
// q[*] -> *NULL_POINTER* , MAY
// q[*] -> _q_4[*][0] , MAY


// Points To OUT: none

void call02(int i, int j, int y[10], int *q[10], tf_t *p)
{

// Points To: none

   /* i can be modified locally, but it won't show in the summary
        effects... which creates a problem for transformer and
        precondition computation. */
   i = j+1;

// Points To: none

   y[i] = 0;

// Points To:
// p -> *NULL_POINTER* , MAY
// p -> _p_5[0] , MAY

   p->one = 1;

// Points To:
// p -> _p_5[0] , EXACT

   (p->two)[j] = 2.;

// Points To:
// p -> _p_5[0] , EXACT
// q[*] -> *NULL_POINTER* , MAY
// q[*] -> _q_4[*][0] , MAY

   *q[i] = 3;
}

Proper effects with points-to for call02

void call02(int i, int j, int y[10], int *q[10], tf_t *p)
{
//             <    is read   >: j
//             <    is written>: i
   /* i can be modified locally, but it won't show in the summary
        effects... which creates a problem for transformer and
        precondition computation. */
   i = j+1;
//             <    is read   >: i
//             <    is written>: y[i]
   y[i] = 0;
//             <may be written>: _p_5[0].one
//             <    is read   >: p
   p->one = 1;
//             <    is read   >: j p
//             <    is written>: _p_5[0].two[j]
   (p->two)[j] = 2.;
//             <may be written>: _q_4[*][0]
//             <    is read   >: i q[i]
   *q[i] = 3;
}

Cumulated effects with points-to for call02

//             <may be read   >: q[*]
//             <may be written>: _p_5[0].one _p_5[0].two[*] _q_4[*][0]
//                               y[*]
//             <    is read   >: i j p
void call02(int i, int j, int y[10], int *q[10], tf_t *p)
{
//             <    is read   >: j
//             <    is written>: i
   /* i can be modified locally, but it won't show in the summary
        effects... which creates a problem for transformer and
        precondition computation. */
   i = j+1;
//             <may be written>: y[*]
//             <    is read   >: i
   y[i] = 0;
//             <may be written>: _p_5[0].one
//             <    is read   >: p
   p->one = 1;
//             <may be written>: _p_5[0].two[*]
//             <    is read   >: j p
   (p->two)[j] = 2.;
//             <may be read   >: q[*]
//             <may be written>: _q_4[*][0]
//             <    is read   >: i
   *q[i] = 3;
}

Points-to for "main"


// Points To IN: none


// Points To OUT: none

int main()
{

// Points To: none

   int a = 1;

// Points To: none

   int b = 2;

// Points To: none

   int x[10], aa[10], i;

// Points To: none

   int *ap[10];

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , EXACT

   tf_t s;

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , EXACT

   tf_t *sp = &s;

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , EXACT
// sp -> s , EXACT

   
   /* Initialization added to avoid a segfault in the callee */
   for(i = 0; i <= 9; i += 1)

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , MAY
// ap[*] -> aa[*] , MAY
// sp -> s , EXACT

      ap[i] = &aa[i];

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , MAY
// ap[*] -> aa[*] , MAY
// sp -> s , EXACT


   call02(a, b, x, ap, sp);

// Points To:
// ap[*] -> *ANY_MODULE*:*NOWHERE*_b0 , MAY
// ap[*] -> aa[*] , MAY
// sp -> s , EXACT

   return 0;
}

Proper effects with points-to for "main"

int main()
{
//             <    is written>: a
   int a = 1;
//             <    is written>: b
   int b = 2;
   int x[10], aa[10], i;
   int *ap[10];
   tf_t s;
//             <    is written>: sp
   tf_t *sp = &s;
//             <    is written>: i
   
   /* Initialization added to avoid a segfault in the callee */
   for(i = 0; i <= 9; i += 1)
//             <    is read   >: i
//             <    is written>: ap[i]
      ap[i] = &aa[i];
//             <may be read   >: ap[*]
//             <may be written>: aa[*] s.one s.two[*] x[*]
//             <    is read   >: a b sp

   call02(a, b, x, ap, sp);
   return 0;
}
