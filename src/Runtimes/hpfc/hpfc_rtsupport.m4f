c
c Runtime Support Functions for the High Performance Fortran Compiler
c by Fabien COELHO.
c
c $RCSfile: hpfc_rtsupport.m4f,v $ version $Revision$
c ($Date: 1996/08/21 16:54:27 $, )
c
c-----------------
c
c HPFC_TEMPLATE
c
c this subroutine computes the coordonates of array number an 
c on the template tn
c
      subroutine HPFC_TEMPLATE(inda, an, indt, tn)
      integer inda(7), an, indt(7), tn
      include "hpfc_commons.h"
      integer i, adim
      do i=1, NODIMT(tn)
         adim = ALIGN(an, i, 1)
         if (adim.EQ.INTFLAG) then
c
c no alignment
c
            indt(i) = INTFLAG
         else
            if (adim.EQ.0) then
c
c constant alignment
c
               indt(i) = ALIGN(an, i, 3)
            else
c
c linear alignment
c
               indt(i) = (ALIGN(an, i, 2) * inda(adim)) 
     $              + ALIGN(an, i, 3)
            endif
         endif
      enddo
      end
c
c-----------------
c
c HPFC_PROCESSORS
c
c this subroutine computes on which processor a template element is mapped
c
      subroutine HPFC_PROCESSORS(indt, tn, indp, pn, replicated)
      integer indt(7), tn, indp(7), pn
      logical replicated
      include "hpfc_commons.h"
      integer i, tdim, param
      replicated = .FALSE.
      do i=1, NODIMP(pn)
         tdim = DIST(tn, i, 1)
c
c replicated if a non specified template dimension is distributed
c
         if (indt(tdim).EQ.INTFLAG) then
            replicated = .TRUE.
            indp(i) = INTFLAG
         else
            param = DIST(tn, i, 2)
            if (param.GT.0) then
c
c here the distribution is BLOCK
c
               indp(i) = (((indt(tdim) - RANGET(tn, tdim, 1)) / param) 
     $              + RANGEP(pn, i, 1))
            else
c
c here the distribution is CYCLIC
c
               param = - param
               indp(i) = ( (MOD((indt(tdim) 
     $              - RANGET(tn, tdim, 1)), (param*RANGEP(pn, i, 3))) 
     $              / param) + RANGEP(pn, i, 1) )
            endif
         endif
      enddo
      end
c
c-----------------
c
c HPFC_PROCLID
c
      subroutine HPFC_PROCLID(indp, pn, lid, replicated)
      integer indp(7), pn, lid
      logical replicated
      include "hpfc_commons.h"
      integer i, t
      if (replicated) then
         lid = INTFLAG
      else
         if (NODIMP(pn).EQ.0) then
            lid = 1
         else
            t = indp(1) - RANGEP(pn, 1, 1)
            do i=2, NODIMP(pn)
               t = (t * RANGEP(pn, i, 3))
     $              + (indp(i) - RANGEP(pn, i, 1))
            enddo
            lid = t+1
         endif
      endif
      end
c
c-----------------
c
c HPFC_CMPLID
c
      integer function HPFC_CMPLID(pn, p1, p2, p3, p4, p5, p6, p7)
      integer pn, p1, p2, p3, p4, p5, p6, p7
      include "hpfc_commons.h"
      integer lid, indp(7)
      indp(1)=p1
      indp(2)=p2
      indp(2)=p3
      indp(4)=p4
      indp(5)=p5
      indp(6)=p6
      indp(7)=p7
      call HPFC_PROCLID(indp, pn, lid, .FALSE.)
      HPFC_CMPLID=lid
      end
c
c-----------------
c
c HPFC_CMPPOS
c
c returns the vector of indices of lid in pn.
c
      subroutine HPFC_CMPPOS(pn, lid, indp)
      integer pn, lid, indp(7)
      include "hpfc_commons.h"
      integer ndim, i, t, dim, size
      ndim = NODIMP(pn)
      t = lid-1
      do i=0, ndim-1
         dim = ndim-i
         size = RANGEP(pn, dim, 3)
         indp(dim) = MOD(t, size) + RANGEP(pn, dim, 1)
         t = t / size
      enddo
      end
c
c-----------------
c
c true if dimension dim of processor arrangement pn 
c is a distributed dimension for array an.
c
      logical function HPFC_DIST_P(an, dim)
      integer an, dim
      include "hpfc_commons.h"
      HPFC_DIST_P = ALIGN(an, DIST(ATOT(an), dim, 1), 1).ne.INTFLAG 
      end
c
c-----------------
c
c true if lid and the current pe are twins (hold same data) 
c on processor arrangement of array an.
c most of the information computed here could be precomputed and store
c once at the initialization phase of the runtime. 
c
      logical function HPFC_TWIN_P(an, lid)
      integer an, lid
      include "hpfc_commons.h"
      external HPFC_DIST_P
      logical HPFC_DIST_P
      integer ip(7), pn, dim
      pn = TTOP(ATOT(an))
      call HPFC_CMPPOS(pn, lid, ip)
      do dim=1, NODIMP(pn)
         if (HPFC_DIST_P(an, dim).and.ip(dim).ne.MYPOS(dim,pn)) then
            HPFC_TWIN_P = .FALSE.
            return
         endif
      enddo
c
c now the pe id on pn maybe differs ONLY on replicated dimensions
c
      HPFC_TWIN_P = .TRUE.
      end
c
c-----------------
c
c HPFC_CMPOWNERS
c
      subroutine HPFC_CMPOWNERS(an, i1, i2, i3, i4, i5, i6, i7)
      integer an, i1, i2, i3, i4, i5, i6, i7
      include "hpfc_commons.h"
      integer inda(7), indt(7), indp(7), tn, i
      inda(1) = i1
      inda(2) = i2
      inda(3) = i3
      inda(4) = i4
      inda(5) = i5
      inda(6) = i6
      inda(7) = i7
      tn  = ATOT(an)
      OPN = TTOP(tn)
      call HPFC_TEMPLATE(inda, an, indt, tn)
      call HPFC_PROCESSORS(indt, tn, OINDP, OPN, OREPLICATED)
      if (OREPLICATED) then
         OLID = INTFLAG
         OWNERTID = INTFLAG
         do i=1, NODIMP(OPN)
            if (OINDP(i).EQ.INTFLAG) then
               indp(i) = RANGEP(OPN, i, 1)
            else
               indp(i) = OINDP(i)
            endif
         enddo
         call HPFC_PROCLID(indp, OPN, SLID, .FALSE.)
         SENDERTID  = NODETIDS(SLID)
      else
         call HPFC_PROCLID(OINDP, OPN, OLID, OREPLICATED)
         OWNERTID  = NODETIDS(OLID)
         SENDERTID = OWNERTID
         SLID = OLID
      endif
      end
c
c-----------------
c
c HPFC_CMPCOMPUTER
c
      subroutine HPFC_CMPCOMPUTER(an, i1, i2, i3, i4, i5, i6, i7)
      integer an, i1, i2, i3, i4, i5, i6, i7
      include "hpfc_commons.h"
      integer inda(7), indt(7), tn, i
      logical replicated
      inda(1) = i1
      inda(2) = i2
      inda(3) = i3
      inda(4) = i4
      inda(5) = i5
      inda(6) = i6
      inda(7) = i7
      tn  = ATOT(an)
      CPN = TTOP(tn)
      call HPFC_TEMPLATE(inda, an, indt, tn)
      call HPFC_PROCESSORS(indt, tn, CINDP, CPN, replicated)
      if (replicated) then
         do i=1, NODIMP(CPN)
            if (CINDP(i).EQ.INTFLAG) 
     $           CINDP(i) = RANGEP(CPN, i, 1)
         enddo
         replicated = .FALSE.
      endif
      call HPFC_PROCLID(CINDP, CPN, CLID, replicated)
      COMPUTERTID  = NODETIDS(CLID)
      CPOSCOMPUTED = .FALSE.
      end
c
c-----------------
c
c HPFC_CMPNEIGHBOUR
c
c this function computes the neighbour tid of the current process,
c given the delta switch in the linearised processors representation.
c
      subroutine HPFC_CMPNEIGHBOUR(delta)
      integer delta
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid
      NLID = MYLID + DELTA
      NTID = NODETIDS(NLID)
c
c where should I put it?
c
      call pvmfinitsend(PVMRAW, bufid)
      end
c
c-----------------
c
c HPFC_OWNERP
c
c
      logical function HPFC_OWNERP()
      include "hpfc_commons.h"
      logical result
      integer i
      if (OREPLICATED) then
         result = .TRUE.
         do i=1, NODIMP(OPN)
            if (OINDP(i).NE.INTFLAG) 
     $           result = result.AND.(OINDP(i).EQ.MYPOS(i, OPN))
         enddo
      else
         result = MYLID.EQ.OLID
      endif
      HPFC_OWNERP = result
      end
c
c-----------------
c
c HPFC_SENDERP
c
c
      logical function HPFC_SENDERP()
      include "hpfc_commons.h"
      HPFC_SENDERP = MYLID.EQ.SLID
      end
c
c-----------------
c
c HPFC_COMPUTERP
c
c
      logical function HPFC_COMPUTERP()
      include "hpfc_commons.h"
      HPFC_COMPUTERP = MYLID.EQ.CLID
      end
c
c-----------------
c
c HPFC_COMPUTERINOWNERSP
c
c
      logical function HPFC_COMPUTERINOWNERSP()
      include "hpfc_commons.h"
      logical result
      integer i
      if (OREPLICATED) then
         result = .TRUE.
         if (OPN.EQ.CPN) then
c
c both owners and computer are set on the same processors.
c
            do i=1, NODIMP(OPN)
               if (OINDP(i).NE.INTFLAG)
     $              result = result.AND.(OINDP(i).EQ.CINDP(i))
            enddo
         else
c
c the processors are different, we have to compute the computer
c position on the owners processors, if it has not been done.
c
            if ((.NOT.CPOSCOMPUTED).OR.(CPOSPN.NE.OPN)) then
               call HPFC_CMPPOS(OPN, CLID, CPOS)
               CPOSPN = OPN
               CPOSCOMPUTED = .TRUE.
            endif
            do i=1, NODIMP(OPN)
               if (OINDP(i).NE.INTFLAG)
     $              result = result.AND.(OINDP(i).EQ.CPOS(i))
            enddo
         endif
      else
         result = CLID.EQ.OLID
      endif
      HPFC_COMPUTERINOWNERSP = result
      end

c
c-----------------
c
c HPFC_SNDTO_C
c send to computer
c
      subroutine HPFC_SNDTO_C(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(COMPUTERTID, SENDCHANNELS(CLID), info)
      SENDCHANNELS(CLID) = SENDCHANNELS(CLID) + 2
      end
c
c-----------------
c
c HPFC_SNDTO_H
c
c send to host
c
      subroutine HPFC_SNDTO_H(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(HOSTTID, HOSTCHANNEL, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      end
c
c-----------------
c
c HPFC_SNDTO_O
c
c send to owner, when there is just one
c
      subroutine HPFC_SNDTO_O(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "sending to ", OLID)
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(OWNERTID, SENDCHANNELS(OLID), info)
      SENDCHANNELS(OLID) = SENDCHANNELS(OLID) + 2
      end
c
c-----------------
c
c HPFC_SNDTO_A
c
c send to all nodes
c
      subroutine HPFC_SNDTO_A(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      if (MYLID.GT.1)
     $     call pvmfmcast(
     $     MYLID-1, 
     $     NODETIDS, 
     $     MCASTNODES, 
     $     info)
      if (MYLID.LT.NBOFTASKS)
     $     call pvmfmcast(
     $     NBOFTASKS-MYLID, 
     $     NODETIDS(MYLID+1), 
     $     MCASTNODES, 
     $     info)
      MCASTNODES = MCASTNODES + 2
      end
c
c-----------------
c
c HPFC_PVMLENGTH
c
      integer function HPFC_PVMLENGTH(what)
      integer what
      include "fpvm3.h"
      if (what.eq.INTEGER4.or.what.eq.REAL4) then
         HPFC_PVMLENGTH=4
         return
      endif
      if (what.eq.REAL8.or.what.eq.COMPLEX8) then
         HPFC_PVMLENGTH=8
         return
      endif
      if (what.eq.BYTE1) then
         HPFC_PVMLENGTH=1
         return
      endif
      if (what.eq.INTEGER2) then
         HPFC_PVMLENGTH=2
         return
      endif
      if (what.eq.COMPLEX16) then
         HPFC_PVMLENGTH=16
         return
      endif
      write (unit=0,fmt=*) "[HPFC_PVMLENGTH] unexpected tag ", what
      stop
      end
c
_CM5(
c-----------------
c
c CM_SNDTO_A
c
c send to all nodes, cmmd version
c
      subroutine CM_SNDTO_A(what, val)
      integer what, val
      include "cmmd_fort.h"
      include "hpfc_commons.h"
      external HPFC_PVMLENGTH
      integer HPFC_PVMLENGTH
      integer i, len
      len = HPFC_PVMLENGTH(what)
      do i=1, NBOFTASKS
         if (i.ne.MYLID) then
            if (0.ne.CMMD_send(
     $           CM_NODE_IDS(i),
     $           MCASTNODES,
     $           val,
     $           len)) then
               write (unit=0,fmt=*)
     $              "[CM_SNDTO_A] send error ", MYLID, " to ", i
            endif
         endif
      enddo
      MCASTNODES = MCASTNODES + 2
      end
c
c-----------------
c
c CM_RCVFR_mCS
c
      subroutine CM_RCVFR_mCS(what, goal)
      integer what, goal
      include "cmmd_fort.h"
      include "hpfc_commons.h"
      external HPFC_PVMLENGTH
      integer HPFC_PVMLENGTH
      integer len
      len = HPFC_PVMLENGTH(what)
      if (0.ne.CMMD_receive(
     $     CM_NODE_IDS(SLID),
     $     MCASTNODES,
     $     goal,
     $     len)) then
         write (unit=0,fmt=*) "[CM_RCVFR_mCS] receive error on ", MYLID
      endif
      MCASTNODES = MCASTNODES + 2
      end
c)
c-----------------
c
c HPFC_HSNDTO_A
c
c host send to all nodes
c
      subroutine HPFC_HSNDTO_A(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "sending to all nodes")
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, MCASTHOST, info)
      MCASTHOST = MCASTHOST + 2
      debug(write (unit=0,fmt=*) "sent!")
      end
c
c-----------------
c
c HPFC_SNDTO_HA
c
c send to host and all nodes, but not the sender.
c
      subroutine HPFC_SNDTO_HA(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      if (MYLID.GT.1)
     $     call pvmfmcast(
     $     MYLID-1, 
     $     NODETIDS, 
     $     MCASTNODES, 
     $     info)
      if (MYLID.LT.NBOFTASKS)
     $     call pvmfmcast(
     $     NBOFTASKS-MYLID, 
     $     NODETIDS(MYLID+1), 
     $     MCASTNODES, 
     $     info)
      MCASTNODES = MCASTNODES + 2
      call pvmfsend(HOSTTID, HOSTCHANNEL, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      end
c
c-----------------
c
c HPFC_SNDTO_OS
c
c send to owners, by someone who is not in owners
c
      subroutine HPFC_SNDTO_OS(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, i
      integer i1, i2, i3, i4, i5, i6, i7
      integer lb(7), ub(7), indp(7), lid
      if (OREPLICATED) then
         do i=1, NODIMP(OPN)
            debug(write (unit=0,fmt=*) "i = ", i, " index is ", OINDP(i))
            if (OINDP(i).EQ.INTFLAG) then
               lb(i) = RANGEP(OPN, i, 1)
               ub(i) = RANGEP(OPN, i, 2)
            else
               lb(i) = OINDP(i)
               ub(i) = OINDP(i)
            endif
            debug(write (unit=0,fmt=*) "bounds ", lb(i), ub(i))
         enddo
         do i=(NODIMP(OPN)+1), 7
            lb(i) = 1
            ub(i) = 1
         enddo
         call pvmfinitsend(PVMRAW, bufid)
         call pvmfpack(what, val, 1, 1, info)
         do i7=lb(7), ub(7)
            indp(7) = i7
            do i6=lb(6), ub(6)
               indp(6) = i6
               do i5=lb(5), ub(5)
                  indp(5) = i5
                  do i4=lb(4), ub(4)
                     indp(4) = i4
                     do i3=lb(3), ub(3)
                        indp(3) = i3
                        do i2=lb(2), ub(2)
                           indp(2) = i2
                           do i1=lb(1), ub(1)
                              indp(1) = i1
c     
c too much computation is made inside this call, and some 
c factorisation could be made out of the inner loop, but I don t
c have time for that...
c
                              call HPFC_PROCLID(
     $                             indp, OPN, lid, .FALSE.)
                              call pvmfsend(
     $                             NODETIDS(lid), 
     $                             SENDCHANNELS(lid), 
     $                             info)
                              SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
                              debug(write (unit=0,fmt=*) "sending to ", lid)
                           enddo
                        enddo
                     enddo
                  enddo
               enddo
            enddo
         enddo
      else
         call HPFC_SNDTO_O(what, val)
      endif
      end
c
c-----------------
c
c HPFC_SNDTO_OOS
c
c send to other owners, if any
c
      subroutine HPFC_SNDTO_OOS(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info,  i
      integer i1, i2, i3, i4, i5, i6, i7
      integer lb(7), ub(7), indp(7), lid
      do i=1, NODIMP(OPN)
         debug(write (unit=0,fmt=*) "i = ", i, " index is ", OINDP(i))
         if (OINDP(i).EQ.INTFLAG) then
            lb(i) = RANGEP(OPN, i, 1)
            ub(i) = RANGEP(OPN, i, 2)
         else
            lb(i) = OINDP(i)
            ub(i) = OINDP(i)
         endif
         debug(write (unit=0,fmt=*) "bounds ", lb(i), ub(i))
      enddo
      do i=(NODIMP(OPN)+1), 7
         lb(i) = 1
         ub(i) = 1
      enddo
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      do i7=lb(7), ub(7)
         indp(7) = i7
         do i6=lb(6), ub(6)
            indp(6) = i6
            do i5=lb(5), ub(5)
               indp(5) = i5
               do i4=lb(4), ub(4)
                  indp(4) = i4
                  do i3=lb(3), ub(3)
                     indp(3) = i3
                     do i2=lb(2), ub(2)
                        indp(2) = i2
                        do i1=lb(1), ub(1)
                           indp(1) = i1
c
c too much computation is made inside this call, and some 
c factorisation could be made out of the inner loop, but I don t
c have time for that...
c
                           call HPFC_PROCLID(indp, OPN, lid, .FALSE.)
                           if (lid.NE.CLID) then
                              call pvmfsend(
     $                             NODETIDS(lid), 
     $                             SENDCHANNELS(lid), 
     $                             info)
                              SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
                           endif
                        enddo
                     enddo
                  enddo
               enddo
            enddo
         enddo
      enddo
      end
c
c-----------------
c
c HPFC_SNDTO_NO
c
c send to not owners, when replicated...
c
      subroutine HPFC_SNDTO_NO(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, i, indp(7), ndim, lid
      logical result
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      ndim = NODIMP(OPN)
      do lid=1, NBOFTASKS
c
c this leads to much much stupid computation, but all I need is the function
c done, and not the performances... however I think a better job could be done
c
c is lid in owners ?
c         
         call HPFC_CMPPOS(OPN, lid, indp)
         result = .TRUE.
         do i=1, ndim
            if (OINDP(i).NE.INTFLAG)
     $           result = result.AND.(OINDP(i).EQ.indp(i))
         enddo
         if (.NOT.result) then
            call pvmfsend(NODETIDS(lid), SENDCHANNELS(lid), info)
            SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
         endif
      enddo
      end
c     
c-----------------
c
c HPFC_SNDTO_HNO
c
c send to host and not owners, when replicated
c
      subroutine HPFC_SNDTO_HNO(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      call HPFC_SNDTO_H(what, val)
      call HPFC_SNDTO_NO(what, val)
      end
c
c-----------------
c
c HPFC_RCVFR_S
c
      subroutine HPFC_RCVFR_S(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(SENDERTID, RECVCHANNELS(SLID), bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      RECVCHANNELS(SLID) = RECVCHANNELS(SLID) + 2
      end
c
c-----------------
c
c HPFC_RCVFR_C
c
      subroutine HPFC_RCVFR_C(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(COMPUTERTID, RECVCHANNELS(CLID), bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      RECVCHANNELS(CLID) = RECVCHANNELS(CLID) + 2
      end
c
c-----------------
c
c HPFC_RCVFR_H
c
      subroutine HPFC_RCVFR_H(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(HOSTTID, HOSTCHANNEL, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      debug(write (unit=0,fmt=*) MYLID, " receiving from host")
      end
c
c-----------------
c
c HPFC_RCVFR_mCS
c
      subroutine HPFC_RCVFR_mCS(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(SENDERTID, MCASTNODES, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      MCASTNODES = MCASTNODES + 2
      end
c
c-----------------
c
c HPFC_RCVFR_mCH
c
      subroutine HPFC_RCVFR_mCH(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "receiving from host")
      call pvmfrecv(HOSTTID, MCASTHOST, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      MCASTHOST = MCASTHOST + 2
      debug(write (unit=0,fmt=*) "received!")
      end
c
c-----------------
c
c HPFC_LOCALINDGAMMA
c
c computation of the gamma function for local indice access
c
c
      integer function HPFC_LOCALINDGAMMA(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
      integer n, sc, no, bmtm
      integer t, nc, ni
c
c static parameters for the computation
c
      n    = RANGEA(an, dim, 5)
      sc   = RANGEA(an, dim, 6)
      no   = RANGEA(an, dim, 7)
      bmtm = RANGEA(an, dim, 8)
c
c the computation
c
      t    = indice + bmtm
      nc   = t / sc
      ni   = MOD(t, n)
      HPFC_LOCALINDGAMMA = n*(nc-no) + ni + 1
      end
c
c-----------------
c
c HPFC_LOCALINDDELTA
c
c computation of the delta function for local indice access
c
c
      integer function HPFC_LOCALINDDELTA(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
      integer n, sc, no, bmtm, rate, chsz
      integer t, nc, ni
c
c static parameters for the computation
c
      n    = RANGEA(an, dim, 5)
      sc   = RANGEA(an, dim, 6)
      no   = RANGEA(an, dim, 7)
      bmtm = RANGEA(an, dim, 8)
      rate = RANGEA(an, dim, 9)
      chsz = RANGEA(an, dim, 10)
c
c the computation
c
      t    = rate*indice + bmtm
      nc   = t / sc
      ni   = MOD(t, n) / abs(rate)
      HPFC_LOCALINDDELTA = chsz*(nc - no) + ni + 1
      end
c
c-----------------
c
c HPFC_LOCALIND
c
c
      integer function HPFC_LOCALIND(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
c
c I cannot include the .h because of the external declaration of the 
c function itself...
c
      external HPFC_LOCALINDGAMMA
      integer HPFC_LOCALINDGAMMA
      external HPFC_LOCALINDDELTA
      integer HPFC_LOCALINDDELTA
      integer newdecl, rate
      newdecl = RANGEA(an, dim, 4)
      if (newdecl.EQ.0) then
c no new declaration
         HPFC_LOCALIND = indice
         return
      else
      if (newdecl.EQ.1) then
c alpha new declaration
         HPFC_LOCALIND = indice - RANGEA(an, dim, 5)
         return
      else
      if (newdecl.EQ.2) then
c beta new declaration
         rate = RANGEA(an, dim, 6)
         HPFC_LOCALIND = 1 +
     &        (MOD(rate*indice+RANGEA(an, dim, 7), 
     &             RANGEA(an, dim, 5)) / ABS(RANGEA(an, dim, 6)))
         return
      else
      if (newdecl.EQ.3) then
c gamma new declaration
         HPFC_LOCALIND = HPFC_LOCALINDGAMMA(an, dim, indice)
         return
      else
         HPFC_LOCALIND = HPFC_LOCALINDDELTA(an, dim, indice)
         return
      endif
      endif
      endif
      endif
      end
c
c-----------------
c
c HPFC_INIT_NODE
c
c this is the entry point in the hpfc runtime library for a node.
c
      subroutine HPFC_INIT_NODE()
      _CM5(include "cmmd_fort.h")
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer i, bufid, info, inum

      call HPFC_CHECK

      call pvmfmytid(MYTID)
      call pvmfparent(HOSTTID)

      NBOFTASKS = MAXSIZEOFPROCS

      _direct(call HPFC_DIRECT_ROUTE_IF_POSSIBLE)

      call HPFC_INIT_COMMON_PROCS
      call HPFC_INIT_COMMON_BUFFER
      call HPFC_INIT_COMMON_PARAM_LIB

      call pvmfrecv(HOSTTID, 1, bufid)
      call pvmfunpack(INTEGER4, NODETIDS, NBOFTASKS, 1, info)
      do i=1, NBOFTASKS
         if (NODETIDS(i).EQ.MYTID)
     $        MYLID = i
      enddo
      do i=1, NBOFPROCESSORS
         call HPFC_CMPPOS(i, MYLID, MYPOS(1, i))
      enddo
      debug(write (unit=0,fmt=*) "lid: ", MYLID, " tid: ", MYTID)

c
c 1 sends node version key to host
c
      if (MYLID.eq.1) then
         call pvmfinitsend(PVMRAW, info)
         call pvmfpack(STRING, hpfc_key, 64, 1, info)
         call pvmfsend(HOSTTID, 1, info)
      endif

_CM5(
c
c cm5 related id initializations
c
      CM_HOST_ID = cmmd_host_node()
      CM_MY_ID   = cmmd_self_address()
      CM_SIZE    = cmmd_partition_size()
c
      call pvmfinitsend(PVMRAW, info)
      call pvmfpack(INTEGER4, CM_MY_ID, 1, 1, info)
      call pvmfsend(HOSTTID, 1, info)
c
      call pvmfrecv(HOSTTID, 1, bufid)
      call pvmfunpack(INTEGER4, CM_NODE_IDS, NBOFTASKS, 1, info)
c
c end of cm5 related initializations
c)
      call pvmfjoingroup(HPFC_GROUP_NAME, inum)
c
c insures that all nodes joined the group
c
      call HPFC_SYNCHRO
      end
c
c-----------------
c
c HPFC_INIT_COMMON_PROCS
c
      subroutine HPFC_INIT_COMMON_PROCS()
      include "hpfc_commons.h"
      integer i
      do i=1, NBOFTASKS
         SENDCHANNELS(i) = 2
      enddo
      do i=1, NBOFTASKS
         RECVCHANNELS(i) = 2
      enddo
      MCASTNODES = 1
      MCASTHOST  = 3
      OPN = 0
      CPOSPN = 0
      HOSTCHANNEL = 2
      end
c-----------------
c
c HPFC_INIT_COMMON_BUFFER
      subroutine HPFC_INIT_COMMON_BUFFER
      include "hpfc_commons.h"
      BYTE1_BUFFSIZE = SIZEOFBUFFER
      INTEGER2_BUFFSIZE = SIZEOFBUFFER/2
      INTEGER4_BUFFSIZE = SIZEOFBUFFER/4
      REAL4_BUFFSIZE = SIZEOFBUFFER/4
      REAL8_BUFFSIZE = SIZEOFBUFFER/8
      COMPLEX8_BUFFSIZE = SIZEOFBUFFER/8
      COMPLEX16_BUFFSIZE = SIZEOFBUFFER/16
      SEND_NOT_INITIALIZED = .TRUE.
      RECEIVED_NOT_PERFORMED = .TRUE.
      end
c
c-----------------
c
c HPFC_INIT_COMMON_PARAM_LIB
c
      subroutine HPFC_INIT_COMMON_PARAM_LIB
      include "hpfc_commons.h"
      integer i
      do i=1, MAXNBOFARRAYS
         LIVEMAPPING(i) = .FALSE.
      enddo
c
c the next routine is compiler generated
c
      call HPFC_INIT_COMMON_PARAM
      end
c
c-----------------
c
c HPFC_DIRECT_ROUTE_IF_POSSIBLE
c
_direct(`'
      subroutine HPFC_DIRECT_ROUTE_IF_POSSIBLE
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer nhost, narch, dtid, speed, info
      character host(50), arch(20)
      call pvmfconfig(nhost, narch, dtid, host, arch, speed, info)
      if (nhost.ge.NBOFTASKS) then
         call pvmfsetopt(PVMROUTE, PVMROUTEDIRECT, info)
      else
         if (HOSTTID.eq.MYTID) write (unit=0,fmt=*)
     $        "Warning: no direct route (not enough processors)..."
      endif
      end
)dnl
c
c
c-----------------
c
c HPFC_INIT_HOST
c
c this is the entry point in the hpfc runtime library for a program.
c
      subroutine HPFC_INIT_HOST()
      _CM5(include "cmmd_fort.h")
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, inum, i
      character*64 node_key

      call HPFC_CHECK

      call pvmfmytid(MYTID)
      MYLID = 0
      HOSTTID = MYTID
      NBOFTASKS = MAXSIZEOFPROCS

      call HPFC_INIT_COMMON_PARAM_LIB

c
c done before the spawn so host is (group, 0)
c
      call pvmfjoingroup(HPFC_GROUP_NAME, inum)
      if (inum.lt.0) then
         call pvmfperror("while joining group", info)
         call pvmfexit(info)
         stop
      endif

      _direct(call HPFC_DIRECT_ROUTE_IF_POSSIBLE)

      debug(write (unit=0,fmt=*) "spawning ", NODE_PROGRAM_NAME
      write (unit=0,fmt=*) "   on ", NBOFTASKS, " ", NODE_ARCHITECTURE)

      call pvmfspawn(
     $     NODE_PROGRAM_NAME, 
     $     PVMARCH, 
     $     NODE_ARCHITECTURE, 
     $     NBOFTASKS, 
     $     NODETIDS, 
     $     info)

      if (info.lt.0) then
         call pvmfperror("initial spawning", info)
         call pvmfexit(info)
         stop
      endif

      if (info.ne.NBOFTASKS) then
         call pvmfperror("not spawned", 0)
         call pvmfexit(0)
         stop
      endif

      demo(call print_host_info)
      demo(call print_task_info(NBOFTASKS, NODETIDS, HOSTTID))

      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(INTEGER4, NODETIDS, NBOFTASKS, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, 1, info)

      debug(if (info.lt.0) then
         call pvmfperror("initial broadcast", info)
         call pvmfexit(info)
         stop
      endif)

      call HPFC_INIT_COMMON_PROCS
      call HPFC_INIT_COMMON_BUFFER
c
c check version of host and node
c to insure that both host and node where generated together...
c
      call pvmfrecv(NODETIDS(1), 1, bufid)
      call pvmfunpack(STRING, node_key, 64, 1, info)
      if (node_key.ne.hpfc_key) then
         print *, "*** incompatible version keys!"
         print *, "*** host: ", hpfc_key
         print *, "*** node: ", node_key
         do i=1, NBOFTASKS
            call pvmfkill(NODETIDS(i), info)
         enddo
         call pvmfexit(info)
         stop
      endif

_CM5(
c
c cm5 related id initializations
c
      CM_HOST_ID = cmmd_self_address()
      CM_MY_ID   = CM_HOST_ID
      CM_SIZE    = cmmd_partition_size()
c
      do i=1, NBOFTASKS
         call pvmfrecv(NODETIDS(i), 1, info)
         call pvmfunpack(INTEGER4, CM_NODE_IDS(i), 1, 1, info)
      enddo
c
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(INTEGER4, CM_NODE_IDS, NBOFTASKS, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, 1, info)
c
c end of cm5 related initializations
c)

c
c insures that all nodes joined the group...
c
      call HPFC_SYNCHRO

      end
c
c-----------------
c
c HPFC_HOST_END
c
      subroutine HPFC_HOST_END()
      integer info
      sync_exit(call HPFC_SYNCHRO)
      call pvmfexit(info)
      stop
      end
c
c-----------------
c
c HPFC_NODE_END
c
      subroutine HPFC_NODE_END()
      integer info
      sync_exit(call HPFC_SYNCHRO)
      call pvmfexit(info)
      stop
      end
c
c-----------------
c
c HPFC_RCVFR_N
c
      subroutine HPFC_RCVFR_N()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      call pvmfrecv(NTID, RECVCHANNELS(NLID), info)
      end
c
c-----------------
c
c HPFC_SNDTO_N
c
      subroutine HPFC_SNDTO_N()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      call pvmfsend(NTID, SENDCHANNELS(NLID), info)
      end
c
c-----------------
c
c HPFC_REMOTE_LOOP_BOUNDS
c
      subroutine HPFC_REMOTE_LOOP_BOUNDS
     $     (nlb, nub, llb, lb, ub, an, dp, pos)
      integer nlb, nub, llb, lb, ub, an, dp, pos
      include "hpfc_commons.h"
      integer d, n, tn, pn, b, dt, da
      if (dp.EQ.0) then
         nlb = lb
         nub = ub
         llb = lb-1
         return
      endif 
      tn = ATOT(an)
      pn = TTOP(tn)
      dt = DIST(tn, dp, 1)
      n  = DIST(tn, dp, 2)
      da = ALIGN(an, dt, 1)
      b  = ALIGN(an, dt, 3)
c
c d is the first template cell of the considered dimension that
c is mapped onto the given processors cell:
c
      d  = n*(pos-RANGEP(pn, dp, 1)) + RANGET(tn, dt, 1)
      llb = MAX(lb, d-b)-1
      nlb = llb+b-d+2
      nub = MIN(ub+b, d+n-1)-d+1
      end
c
c-----------------
c
c
c HPFC_LOOP_BOUNDS
c
c Computation of the local loop bounds:
c nlb (new lower bound) and nub (new upper bound)
c and llb, the local lower bound in the former global loop,
c with lb (initial lower bound) and ub (initial upper bound)
c that access dimension of array da of array number an, mapped
c onto dimension of processors dp of processors number pn.
c 
      subroutine HPFC_LOOP_BOUNDS(nlb, nub, llb, lb, ub, an, dp)
      integer nlb, nub, llb, lb, ub, an, dp
      include "hpfc_commons.h"
      debug(write (unit=0,fmt=*) 
     $     "HPFC_LOOP_BOUNDS ", lb, ub, " array ", an, dp)
      call HPFC_REMOTE_LOOP_BOUNDS
     $     (nlb, nub, llb, lb, ub, an, dp, MYPOS(dp, TTOP(ATOT(an))))
      debug(write (unit=0,fmt=*) 
     $     "init lb: ", llb, " new lb: ", nlb, " new ub: ", nub)
      end
c
c-----------------
c
c HPFC_SYNCHRO
c
      subroutine HPFC_SYNCHRO()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      debug(write (unit=0,fmt=*) 
     $     "[hpfc_synchro] ", MYLID, " waiting ", NBOFTASKS+1)
      call pvmfbarrier(HPFC_GROUP_NAME, NBOFTASKS+1, info)
      if (info.lt.0) then
         call pvmfperror("hpfc_synchro", info)
         call pvmfexit(info)
         stop
      endif
      debug(write (unit=0,fmt=*) "[hpfc_synchro] done")
      end
c
c-----------------
c
c HPFC_HTIMEON
c
      subroutine HPFC_HTIMEON()
      call HPFC_SYNCHRO()
      call HPFC_TIMEON()
      call HPFC_SYNCHRO()
      end
c
c-----------------
c
c HPFC_NTIMEON
c
      subroutine HPFC_NTIMEON()
      call HPFC_SYNCHRO()
      call HPFC_SYNCHRO()
      end
c
c-----------------
c
c HPFC_HTIMEOFF
c
      subroutine HPFC_HTIMEOFF(comment)
      character comment*(*)
      call HPFC_SYNCHRO()
      call HPFC_TIMEOFF(comment)
      end
c
c-----------------
c
c HPFC_NTIMEOFF
c
      subroutine HPFC_NTIMEOFF(comment)
      character comment*(*)
      call HPFC_SYNCHRO()
      end
c
c-----------------
c
c HPFC_DIVIDE
c
      integer function HPFC_DIVIDE(i, j)
      integer i,j
      if (i.ge.0) then
         HPFC_DIVIDE = i/j
      else
         HPFC_DIVIDE = -(-i+j-1)/j
      endif
      end
c
c----------
c
c HPFC_PROCDIM
c
c this could be computed statically, where it is used...
c used for the reductions...
c
      integer function HPFC_PROCDIM(an, ad)
      include "hpfc_commons.h"
      integer an, ad
      integer tn, pn, i, it, ip
      tn = ATOT(an)
      pn = TTOP(tn)
      it = 0
      ip = 0
      do i=1, NODIMT(tn)
         if (ALIGN(an, i, 1).EQ.ad) it = i
      enddo
      if (it.NE.0) then
         do i=1, NODIMP(pn)
            if (DIST(tn, i, 1).EQ.it) ip = i
         enddo
      endif
      HPFC_PROCDIM = ip
      return
      end
c
c-----------------
