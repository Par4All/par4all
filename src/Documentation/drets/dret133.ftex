\documentstyle[12pt]{article}
%\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

%\newcommand{\titre}{PIPSMAKE ET PIPSDBM \\
%			MOTIVATIONS ET FONCTIONALITES
%}

\author{Re'mi TRIOLET}
\title{PIPSMAKE ET PIPSDBM \\
			MOTIVATIONS ET FONCTIONALITES\\
TR EMP E133}
\date{Septembre 1990}

%\newcommand{\numero}{E133}

\setlength{\parindent}{0cm}

\newcommand{\draw}[2]{
    \begin{figure}
	\begin{center}
	    \include{#1}
	\end{center}
   	\caption{#2}
    \end{figure}
}

\newcommand{\domain}[2]{
	\paragraph{#1}
	\paragraph{}{
		\em #2
	}
}

\begin{document}
\maketitle
\sloppy
%\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

\section{Introduction}

 
Ce document n'a pas e'te' incorpore' au pre'ce'dent rapport d'avancement
car les travaux qui y sont de'crits ne font pas partie du cahier des
charges initial du projet PIPS. 

 
Ce travail e'tait ne'ammoins ne'cessaire, ainsi que nous l'expliquons
ci-dessous, et il justifie une partie du retard pris par le projet.
C'est pourquoi nous l'exposons maintenant.

\section{Motivations}

 
Pips est un logiciel assez complexe qui se compose de plusieurs phases
d'analyse de programme et de plusieurs phases de transformation de
programme (cf. figure \ref{org}). Pips n'est pas conc,u pour que ces
diffe'rentes phases soient applique'es a` un programme selon un
enchainement strict, mais au contraire pour qu'elles soient applique'es
sur la demande de l'utilisateur en fonction des transformations qu'il
souhaite effectuer sur son programme.

 
Les diffe'rentes phases ne sont cependant pas tout a` fait
inde'pendantes les unes des autres. Ainsi, la plupart des
transformations ne'cessitent que les re'sultats d'une ou plusieurs
analyses soient disponibles; par exemple, la paralle'lisation ne peut
e^tre faite que si le graphe des de'pendances a e'te' calcule'. Quant
aux analyses, il existe un ordre partiel entre elles; par exemple, le
calcul des de'pendances ne peut e^tre fait que si les effets et les
pre'conditions sont disponibles.

 
Il n'est pas possible d'imposer a` l'utilisateur la connaissance de ces
relations de de'pen\-dan\-ces entre phases. C'est pourquoi Pips est
organise' autour d'une base de donne'es capable a` la fois de stocker
l'information calcule'e par chaque phase, et d'appliquer une ou
plusieurs phases dans le bon ordre lorsqu'on lui demande l'acce`s a` des
donne'es non encore disponibles.

 
Le logiciel responsable de l'archivage des donne'es est le {\em
gestionnaire des ressources}; il s'appelle {\em Pipsdbm}. Le logiciel
responsable de l'enchainement des phases est le {\em contro^leur des
ressources}; il s'appelle {\em Pipsmake}.

\section{Fonctionnalite's du contro^leur}

 
L'organisation du projet PIPS est de'crite dans la figure \ref{org}. 
\draw{pips-org}{\label{org}Organisation du projet PIPS}


Les deux interfaces utilisateurs W-Pips et T-Pips (en haut de la figure)
permettent a` l'utilisateur d'appliquer des transformations sur les
modules de son programme, puis d'afficher le re'sultat de ces
transformations sur l'e'cran. Des informations supple'mentaires peuvent
e^tre incluses dans le texte source du programme par les pretty-printers.


Ces deux interfaces ne dialoguent qu'avec le contro^leur des ressources,
ainsi que le montre la figure.  C'est lui qui se charge d'exe'cuter
re'ellement les diffe'rentes transformations et les diffe'rentes
analyses. Nous avons vu que ces diffe'rentes phases e'taient
interde'pendantes. Le proble`me est d'autant plus complique' que PIPS
est interproce'dural.


Par exemple, pour calculer les pre'conditions des instructions d'un
module {\tt M}, il faut non seulement disposer des effets des
instructions de {\tt M} (pour ne pas propager les pre'conditions sur des
variables dont la valeur peut e^tre modifie'e), mais il faut disposer en
outre des {\em transformeurs re'sume's} de tous les modules appele's par
{\tt M} (pour propager les pre'conditions a` travers les appels de
proce'dure).


Pipsmake est responsable de l'enchainement correct des transformations
et des analyses. Pipsmake tient compte des de'pendances directes entre
phases; ces de'pendances lui sont donne'es par un fichier de description
des phases de Pips. Un exemple de de'pendance directe est que la phase
de paralle'lisation ne peut e^tre applique'e a` un module que si le
graphe des de'pendance est disponible (i.e. a e'te' calcule' auparavant)
pour ce me^me module.


Pipsmake tient aussi compte des de'pendances indirectes qui sont dues a`
l'interproce'dura\-li\-te'. Pour cela, Pipsmake dispose du graphe des
appels du programme en cours d'analyse. Ce graphe est calcule' au moment
de la cre'ation d'un programme, lorsque l'utilisateur indique de quels
fichiers Fortran le programme qu'il souhaite cre'er est compose'. Il est
a` noter que l'existence d'un enchainement est en partie due a` la
non-re'cursivite' de Fortran.


L'enchainement impose' par Pipsmake garantit que les informations dont
une phase a besoin ont e'te' calcule'es pre'alablement a` l'exe'cution
de cette phase. Calculer les informations est une chose, savoir les
retrouver au moment opportun en est une autre; c'est le ro^le de
Pipsdbm, le gestionnaire des ressources.

\section{Imple'mentation du contro^leur}


La description des interde'pendances statiques entre phases est contenue
dans un objet Newgen de type {\tt makefile} dont la description est
donne'e dans la section \ref{makefile}. Cet objet est initialise' a`
partir du fichier de configuration {\tt pipsmake.rc} donne' dans la
section \ref{pipsmake.rc}.


Du point de vue de W-Pips et T-Pips, Pipsmake propose deux fonctions
pour de'clencher le calcul de ressources:
\begin{verbatim}
   void make(ressource_name, module_name)
   string ressource_name, module_name;
   { ... }

   void apply(transformation_name, module_name)
   string transformation_name, module_name;
   { ... }
\end{verbatim}


{\tt Make} permet de de'clencher le calcul d'une ressource particulie`re
pour un module donne'. {\tt Apply} permet d'exe'cuter une
transformation, quelles que soient les ressources dont cette
transformation a besoin.

\section{Fonctionnalite's du gestionnaire}


Le gestionnaire des ressources entretient un base de donne'es pour
chaque programme utilisateur sur lequel PIPS est utilise'.


Un programme utilisateur est compose' d'une collection d'objets de
diffe'rentes natures. Ces objets sont appele's {\em ressource} dans la
terminologie Pips. 


Selon sa nature, une {\tt ressource} peut repre'senter:

\begin{itemize}

\item 
le texte source d'un module du programme: source Fortran;

\item
une partie de la repre'sentation interne du programme:
graphe des appels, code d'un module, entite's du programme, ...

\item
une de'coration d'un module du programme: effets des instructions,
re'gions locales des instructions, graphe des de'pendances,
pre'conditions des instructions, ...

\item
un re'sume' d'une de'coration d'un module: effets re'sume's d'un module,
re'gions globales d'un module, pre'conditions d'un module, ...

\item
un re'sultat des diffe'rents prettyprinters: source fortran commente',
liste des erreurs de typage du programme utilisateur, ...

\item 	
etc ...

\end{itemize}


Certaines {\tt ressources} doivent toujours re'sider en me'moire (les
entite's), d'autres ne peuvent que re'sider sur fichier (sources
Fortran), d'autres enfin peuvent migrer d'un fichier vers la me'moire,
et re'ciproquement, au gre' des besoins et de la place me'moire
disponible. Les ressources pouvant migrer sont dites {\em actives}
lorsqu'elles sont en me'moire et {\em inactives} sinon. L'utilisation
d'une ressource ne'cessite que celle-ci soit active.


Le programme de l'utilisateur e'volue en fonction des phases qui sont
exe'cute'es par Pipsmake sur reque^te de l'utilisateur. Une phase qui a
besoin d'une ressource pour un certain module en demande l'activation et
re'cupe`re ainsi un descripteur de la ressource qui lui permet d'y
acce'der. Rappelons que l'existence de la ressource est garantie par
Pipsmake. Chaque phase qui calcule une nouvelle ressource doit {\em
de'poser} cette ressource dans la base pour que celle-ci soit
re'cupe'rable par d'autres phases.


Pipsdbm doit donc entretenir une description de ce qui se trouve dans la
base a` tout instant. Il doit notamment savoir dans quels fichiers
re'sident les diffe'rents objets. Pour chaque type de ressource, Pipsdbm
connait les se'quences d'instructions a` exe'cuter pour e'crire cette
ressource sur fichier, pour la lire depuis un fichier ou pour libe'rer
l'espace me'moire qu'elle occuppe. Ceci lui permet de faire migrer les
ressources devenues inactives (par exemple les ressources les moins
re'cemment utilise'es) de la me'moire vers un fichier, et
re'ciproquement pour les ressources dont l'activation a e'te' demande'e.


Ces se'quences d'instructions sont inscrites dans une table de me'thode
qui indique au gestionnaire les fonctions a` utiliser. Ces fonctions sont
majoritairement {\tt gen\_read}, {\tt gen\_write}, {\tt gen\_free} ou
{\tt gen\_consistent\_p}; cette de`rnie`re ve'rifiant la consistence Newgen 
de la ressource. Cependant, Newgen ne ge'ne'rant pas toutes les fonctions 
ade'quates, plusieurs ressources sont ge're'es par des fonctions 
spe'cifiques. Lors du de'veloppement, s'il y a ajout d'une nouvelle 
ressource, il est donc ne'cessaire de spe'cifier a` pipsdbm les fonctions a`
utiliser en les indiquant dans cette table.


Lorsque l'activation d'une ressource est demande'e par une phase,
l'existence de la res\-sour\-ce est garantie par Pipsmake. Cette ressource
peut ne'ammoins re'sider temporairement sur fichier, auquel cas Pipsdbm
la charge en me'moire, puis il retourne a` la phase un descripteur dont
la nature de'pend du type de la ressource.

\section{Imple'mentation du gestionnaire}


La description des objets pre'sents dans la base de donne'es est
contenue dans un objet Newgen de type {\tt database} dont la description
est donne'e dans la section \ref{database}. 


L'interface propose'e aux phases d'analyse et de transformation par
Pipsmake se compose de deux fonctions pour de'poser ou retrouver
des ressources.

\begin{verbatim}
   char *db_get_resource(ressource_name, module_name, pure)
   char *ressource_name, *module_name;
   bool pure;
   { ... }
   
   void db_put_resource(ressource_name, module_name, value)
   char *ressource_name, *module_name;
   char *value;
   { ... }
\end{verbatim}


Ces deux fonctions devraient e^tre les seules publiques aux autres passes.
Malheureusement, a` l'heure actuelle, certaines passes font appels a` des
fonctions de plus bas niveau de Pipsdbm.


{\tt Db\_get\_resource} permet
aux phases de retrouver une ressource qui a e'te' de'pose'e auparavant
dans la base par la me^me phase ou par une autre phase. Les ressources
de type fichier sont les fichiers sources ou les re'sultats des
pretty-printers. Les autres ressources sont de type me'moire. Un
descripteur de ressource me'moire est tout simplement un pointeur de
type {\tt (char *)} que la phase doit transformer en un pointeur vers un
objet du bon type par une conversion C.


Le boole'en {\tt pure} permet a` la phase de pre'ciser ses intentions
par rapport a` la ressource: la valeur {\tt TRUE} indique que la
ressource ne sera pas modifie'e et la valeur {\tt FALSE} indique au
contraire que la phase va modifier la ressource (par exemple pour
produire une nouvelle ressource). Dans ce dernier cas, Pipsdbm donne une
copie de la ressource et non pas l'original.


{\tt Db\_put\_resource} permet de de'poser une ressource dans la base.


Les ope'rations de migration entre les fichiers et la me'moire sont
automatiques et ne sont pas visibles des phases. Les fonctions qui
re'alisent ces migrations sont {\tt db\_read}, {\tt db\_load}, {\tt
db\_unload}, etc.

\section{Conclusion}


Nous avons de'ja` pre'sente' les nombreux avantages de l'environnement
propose' par PIPS pour de'velopper, puis inte'grer de nombreuses phases
d'analyse et de transformation de programme. Rappelons les points
essentiels:

\begin{itemize}

\item
une repre'sentation interne simple et uniforme qui permet un
acce`s facile aux donne'es me^me dans des structures de donne'es
complexes;

\item
l'utilisation de l'outil de ge'nie logiciel Newgen qui facilite la
programmation en enrichissant le langage de programmation utilise' et en
facilitant le partage des donne'es;

\item
la grande richesse en phases d'analyse qui permet aux nouvelles
transformations de profiter de leurs re'sultats avec peu de
programmation;

\end{itemize}


Les re'cents de'veloppements sur Pipsmake et Pipsdbm enrichissent
conside'rablement cet environnement. Les transformations n'ont plus a`
enchainer elles me^mes les exe'cutions des analyses puisque cela est
fait par Pipsmake de`s lors que son fichier de configuration est mis a`
jour. De plus, l'acce`s aux donne'es calcule'es par ces analyses est
rendu encore plus facile par Pipsdbm.


Cet enrichissement devrait permettre d'inte'grer tre`s rapidement les
phases de transformation qui sont en cours de de'veloppement et de
terminer le projet PIPS pour la fin de l'anne'e 1990.

\newpage
\section{Annexe - La structure Makefile}
\label{makefile}


Cette section de'crit la structure de donne'es {\tt makefile}. Un objet
de ce type est initialise' par Pipsmake a` partir du fichier {\tt
pipsmake.rc} de'crit dans la section \ref{pipsmake.rc}.

\paragraph{Makefile = rules:rule* x active\_phases:string*}

Le domaine {\tt makefile} est utilise' par le driver de haut niveau
pour de'crire les de'pendances entre les diffe'rentes phases de Pips. Un
{\tt Makefile} est une liste de re`gles ({\tt rule}), chaque re`gle
de'crivant une des phases de Pips. En outre, le {\tt Makefile} donne la
liste des phases qui sont actives a` l'instant pre'sent ({\tt
active\_phases}). Rappelons que chaque type de ressources peut
e'ventuellement e^tre produit par diffe'rentes phases, mais qu'une seule
phase est utilisable a` un instant donne'.

\paragraph{Rule = phase:string x required:virtual\_resource* x produced:virtual\_resource* x preserved:virtual\_resource* x modified:virtual\_resource*}

Le domaine {\tt rule} permet de de'crire les actions des phases de Pips
sur les ressources ge're'es par pips-db. Chaque phase ne'cessite que
certaines ressources soient disponibles ({\tt required}), elle produit
une ou plusieurs ressources ({\tt produced}), et en modifie d'autres
({\tt modified}). La diffe'rence entre les ressources produites et
celles modifie'es permet au driver d'enchainer les phases dans le bon
ordre.


Les phases de transformation agissent sur le code des modules, ce qui
implique ge'ne'rale\-ment que les informations qui de'corent ce module
sont perdues. Pourtant, certaines d'entre-elles font des transformations
si mineures que certaines de'corations sont pre'\-ser\-ve'es ({\tt
preserved}). C'est notamment le cas de la privatisation qui pre'servent
toutes les de'corations.

\paragraph{Virtual\_resource = name:string x owner }

Le domaine {\tt virtual\_resource} permet de de'signer une ressource
lue ou modifie'e par une phase en pre'cisant en plus de la nature de la
ressource ({\tt name}) si la ressource acce'de'e est celle attache'e au
module, au programme, aux modules appele's par le module auquel la phase
est applique'e ou a` celui qui l'appelle ({\tt owner}).

\paragraph{Owner = \{ program , module , callees , caller \}}

Le domaine {\tt owner} permet de pre'ciser dans une re`gle de
de'pendances a` quels modules sont rattache'es les ressources lues,
e'crites, produites ou pre'serve'es. Ce peut e^tre le module lui-me^me
({\tt module}), le programme ({\tt program}), les modules appele's par le
module auquel la phase est applique'e ({\tt callees}) ou a` celui qui
l'appelle ({\tt caller}). Cet attribut supple'mentaire des de'pendances
permet au top-level driver de ge'rer les appels multiples rendus
ne'cessaires par l'interproce'duralite' de Pips.

\newpage
\section{Annexe - Le fichier de configuration de Pipsmake}
\label{pipsmake.rc}


Cette section contient le fichier {\tt pipsmake.rc} qui permet a`
Pipsmake de connaitre la liste des phases applicables a` un programme,
les ressources utilise'es par ces phases (derrie`re le symbole
\verb\<\), les ressources produites (derrie`re le symbole \verb\>\), les
ressources modifie'es (derrie`re le symbole \verb\#\) et les ressources
pre'serve'es (derrie`re le symbole \verb\=\).

\begin{verbatim}
initializer                     > MODULE.source_file
                                > MODULE.user_file

bootstrap                       > PROGRAM.entities

parser                          > MODULE.parsed_code
                                > MODULE.callees
        < PROGRAM.entities
        < MODULE.source_file

controlizer                     > MODULE.controlized_code
        < PROGRAM.entities
        < MODULE.parsed_code

linker                          > MODULE.code
        < PROGRAM.entities
        < MODULE.controlized_code
        < CALLEES.code

proper_effects                  > MODULE.proper_effects
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.summary_effects

cumulated_effects               > MODULE.cumulated_effects
        < PROGRAM.entities
        < MODULE.code MODULE.proper_effects

summary_effects                         > MODULE.summary_effects
        < PROGRAM.entities
        < MODULE.code MODULE.cumulated_effects

chains                         > MODULE.chains
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects MODULE.cumulated_effects

rice_full_dependence_graph      > MODULE.dg
        < PROGRAM.entities
        < MODULE.code
        < MODULE.chains

rice_fast_dependence_graph      > MODULE.dg
        < PROGRAM.entities
        < MODULE.code
        < MODULE.chains

transformers_intra_fast         > MODULE.transformers
        < PROGRAM.entities
        < MODULE.code MODULE.cumulated_effects MODULE.summary_effects

transformers_intra_full         > MODULE.transformers
        < PROGRAM.entities
        < MODULE.code MODULE.cumulated_effects MODULE.summary_effects

transformers_inter_fast         > MODULE.transformers
        < PROGRAM.entities
        < MODULE.code MODULE.cumulated_effects MODULE.summary_effects
        < CALLEES.summary_transformer

transformers_inter_full         > MODULE.transformers
        < PROGRAM.entities
        < MODULE.code MODULE.cumulated_effects MODULE.summary_effects
        < CALLEES.summary_transformer

summary_transformer             > MODULE.summary_transformer
        < PROGRAM.entities
        < MODULE.transformers MODULE.summary_effects

preconditions_intra            > MODULE.preconditions
        < PROGRAM.entities
        < MODULE.transformers

preconditions_inter_fast                > MODULE.preconditions
        < PROGRAM.entities
        < MODULE.transformers
        < MODULE.summary_precondition

preconditions_inter_full                > MODULE.preconditions
        < PROGRAM.entities
        < MODULE.transformers
        < MODULE.summary_precondition

summary_precondition            > MODULE.summary_precondition
        < PROGRAM.entities
        < CALLERS.preconditions

complexities                    > MODULE.complexities
        < PROGRAM.entities
        < MODULE.code MODULE.preconditions
        < CALLEES.summary_complexity

summary_complexity              > MODULE.summary_complexity
        < PROGRAM.entities
        < MODULE.code MODULE.complexities

regions                         > MODULE.regions
        < PROGRAM.entities
        < MODULE.code MODULE.preconditions
        < CALLEES.summary_regions

summary_regions                 > MODULE.summary_regions
        < PROGRAM.entities
        < MODULE.code MODULE.regions

print_code_complexities         > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code MODULE.complexities

print_code_regions              > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code MODULE.regions

print_code                      > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code

print_code_preconditions        > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code MODULE.preconditions

print_code_transformers         > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code MODULE.transformers

print_code_transformers         > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code MODULE.transformers

rice                    > MODULE.parallelized_code
        < PROGRAM.entities
        < MODULE.code MODULE.dg

print_parallelized_code         > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code

distributer                    > MODULE.code
        < PROGRAM.entities
        < MODULE.code MODULE.dg
\end{verbatim}

\newpage
\section{Annexe - La structure Database}
\label{database}


Cette section de'crit la structure de donne'es {\tt database}. Un objet
de ce type est cre'e' et entretenu par Pipsdbm pour chaque programme
Fortran soumis a` PIPS. Cet objet permet a` Pipsdbm de savoir quelles
ressources ont e'te' calcule'es pour ce programme, a` quels modules
sont attache'es les ressources, et ou` se trouvent ces ressources, sur
disque ou en me'moire.

\paragraph{Database = name:string x directory:string x resources:resource*}

Le domaine {\tt database} est utilise' par Pipsdbm pour de'crire
l'e'tat d'un programme utilisateur. Ce domaine contient son nom ({\tt
name}), le re'pertoire dans lequel il a e'te' cre'e', et les
informations qui ont e'te' calcule'es pour les diffe'rents modules ({\tt
resources}).

Un e'le'ment de type {\tt resource} est ajoute' a` la liste {\tt resources}
pour chaque objet calcule' pour ce programme par les phases d'analyse ou
de transformation de Pips.

\paragraph{Resource = name:string x owner\_name:string x status x time:int}

Le domaine {\tt resource} est utilise' par Pipsdbm pour de'crire l'une
des informations suceptibles d'e^tre calcule'es par Pips pour un module
ou un programme. Pour chaque information, il faut connai^tre son nom
({\tt name}), savoir qui elle de'core ({\tt owner\_name}), savoir si elle
est pre'sente en me'moire ou range'e dans un fichier ({\tt status}), et
connaitre sa date de cre'ation ({\tt time}).

Le {\tt name} de la ressource est en fait un type et aurait pu e^tre
de'fini comme un type e'nume're'. C'est par souci de simplicite' et
ge'ne'ricite' de pipsdbm que nous avons choisi de le de'finir comme par
une chaine de caracte`res. C'est ce {\tt name} qui permet notamment a`
pipsdbm de choisir la fonction pour lire, e'crire ou libe'rer une
ressource.

\paragraph{Status = memory:string + file:string}

Le domaine {\tt status} est utilise' par pipsdbm pour savoir si la
ressource concerne'e est re'sident en me'moire ou dans un fichier. Dans
ce dernier cas, le sous-domaine {\tt file} donne le nom de ce fichier.
Si la ressource est en me'moire, le sous-domaine {\tt memory} contient
un pointeur vers cette ressource.

\end{document}
\end
