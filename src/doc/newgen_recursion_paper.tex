\documentstyle{farticle}
\include{/usr/share/local/lib/tex/macroslocales/Dimensions}
\title{Recursive Pattern Matching on Concrete Data Types}

\author{{\em Pierre Jouvelot} \\
CAI, Ecole des Mines de Paris, Fontainebleau (F.) \\
LCS, Massachusetts Institute of Technology, Cambridge (U.S.A.) \\
({\small E-mail: {\tt jouvelot@\{fremp11.bitnet,brokaw.lcs.mit.edu\}}}) \\
\\
{\em Babak Dehbonei} \\
Corporate Research Center, BULL, Louveciennes (F.) \\
({\small E-mail: {\tt Babak.Dehbonei@crg.bull.fr}})}

\date{}

\newcommand{\rpm}{{\tt rpm}}
\newcommand{\E}{\mbox{${\cal E}$}}
\newcommand{\C}{\mbox{${\cal C}$}}
\renewcommand{\P}{\mbox{${\cal P}$}}
\newcommand{\dbl}[1]{\mbox{$\lbrack\!\lbrack$荇１ぼ蜮蜥汶堋茯怛徙毪茴鬻泔眄犷潲芘瘕茯砒痱弩箝镱茴鬻泔眄犷潲苌溴茯射孱糸骈弪茴鬻泔眄犷潲苊忑茯渺狨箦茴鬻泔眄犷潲苄狒茯嗅趑弪铨茆彗轭滹沲礤铘茆彗轭箪镳瘗疳螨茼犭弭轸戾荏邈糸镱深趄镤蹉糸镱澡骢钽糸镱犰痱镧蜥眄轭盹溴驷鲲蝮蝈沲蝮轹溴骈铋糸镱镦骢钽糸镱怡篝蝓泗躜犰轭漉泗轱秭弪躞弪溴骈铄泔钽蝈翦溽翎豉疱螽惋篝骢钽糸镱犰灬铉踽珏ㄥ绠涕箴吞烷蜥钿岈柔箅屐飑镦驽痫麇蜴蹯痱镧蜥眄轭泔铙趄蹉趔翳狒遽箦翳黩轸轭镦痱镧蜥眢忉箦镱翳轶殇遽溴篝蝓泗躜轭荇戾酏荇眭祠轲戾鲠祯瀛忾钿族痱镳矬犷屮翦铙轱麸翳躞踽铒糸镱镦疳趑弪瞽磲翥栝铉汜祆邃苠义沲蝮轹嗅趑弪歪翥栝铉硝盹糸鲠糸镱轶忉箦镱翳镡箦蝣狒轱翳狒盹篝蝈犰扉驽溽翎豉疱狎蝈沲蝮轹瀣瀹绠徕篝蜥泗簌铘狲趄邋蟋泔铘蝻珧狃梵蔑铙羼蹂铘禊磲铢骢钽糸镱翳狒磲铋瘐灬翦翳弩溽翎豉疱狎蝈沲蝮轹瀹澡倚翦汨铋聃泔礅轭弩疳趑弪瞽忉箦溟箴狒汨轭犷蝈沲蝮轹骢钽糸镱汜祆镱篚忏镯痫铄铘镦泔眇戾鲠祯弩澡轶翦汨铋聃栳忮孱篚沣弩箧蹯禊躞邃镱灬蜱筱犰轭箝溴翳皱祜躜痱镪邈舢澡轶鲥泗矧辁轭犷疳蜥祆屐辁轭泔眇殪弪轶北鞍体涕箴扉铄祜铉犷盹篝镦轸盹漉戾躞蝈沲蝮轹疳趑弪磲翥栝铉镱徕篝蜥泗簌铘狲趄邋螽蔑眇狎邃麸骈蝮鲥蝮轱镦皱祜躜翳狒溟漕躞蝈沲蝮轹疳趑弪磲翥栝铉麇镡箦蝣邃舶麸嘲疱沐铘溴泸遽箦苕镲纛雉妍澡轶轫痱邈轶轱泔礤骝镯翳驷泗翳狒翳箦泔钿鲥蝮轱镦皱祜躜犰箫轭趄镤蹉邃铛礤蝻躞孱栳钽屙孱趔翳狒轭骒蹂钽邃翳泔溴箝瀹轭翳箝镦翳泔溴鏖翳秕箝珙殒殂犷疱蜴矧磲钽疱钺祠涕脲犷篝蝓泗躜轭泔钽屦衄麇犰箫铒糸沐翳狒轸躞徵孱翎殪邃篚怏翎铘獒蝈漉泗轱轭翳铛礅弪镦溴箝珙犷泔溟铉弪蝻蝮深翳蝈磲轭溴镦翳轶疳疱颥麇篚蝣妁翳蝈灬翦黠螂箦泗轱博溴骈铄痱邈轶屐翳铒糸镱镦蝈沲蝮轹疳趑弪磲翥栝铉箦泗轱畅玳鲥箦镦箝眇戾屮犴痨弩箦泗轱穿轭鲥篝殓狒骢螋桢轫痱秭屙孱趔箦泗轱旦犷泔钽祯溴箦泗轱订令狃疱钿轼痱秭殇弩泔眇戾翦蔑眄镱躺有轫痨屙孱翎糸镱镦倚彤荏邈糸镱义灬翦罪螂嗅趑弪磲翥栝铉轶犷轫痫螋犷驷汩扉豉痱秭殇邃怡磲铢盹溴蝾痱镧蜥眄轭灬铉踽珏螽箩箝汜祆镱沐玳鲥溽翎豉疱箦孱轭翳轶骝犴鬻矧狍箦镦骢钽糸镱翳狒犰祜翳磲铋瘐灬糸镱镦鲠祯弩镦翳轶豉疱栳忮孱溴骈铄洮疳趑弪铙ㄩ瀹屮痱弩箝镱翳狒轭鲲祧溽翎豉疱骢钽糸镱犷躅怙躅鲠蜷徕戾螬汜狃疱狎狍戾骠栳钿箝溴镦犷忾钿轭泔铙趄蹉艋翳铄彐驽泗轶麸忾钿翳鲠蜷徕戾麸翳泔蝌弩痫钿轭鲠祯弩轭翳蜷玷栳钿箝溴澡蜷玷栳钿箝溴鲠祯栳麸磲翥翳泔蝌弩痫钿轭疳趑弪町澡箝眇戾篝麽镦躞轭翳轶翦汨铋聃轶玳鲥轭磲铢鏖溴禊躞邃轫疱蜥糸鲥灬铉踽珏螽深嗅筱犰凼赘递翳荇汜箦泔眄犷犰祜黧翳痱镧蜥眄弪麸屮邈豸篝狒屙孱趔徙泔蜾轭麸翳鲠祯镦犷轭翦珏矧犷孱蹴弪狒邃鲠蜷徕戾深翳痱镧蜥眄轭灬铉踽珏鬯曳篙犷羼蹰鲠戾铘趄遽繇孱轶疱蜴矧礤镱轭翦珏屮痱弩箝镱躞轭翳荇篦轸汨篝狒屙孱舢蕊麇鲥颥翳弩磲翥栝铉痫篌殁殪轸殄狎铒篚骀殂殄铘禊痫麇蜴蹯麸忮狃痨殄镱盹蝈徕篝蜥泗溽翎深涕箴扉脲灬铉踽珏塾舾摧骒狯矧镦徕篝蜥泗疳趑弪磲翥栝铉轶痱弩孱骘篝蝓泗躜邃扉篝矧趄邋螽澡轶轶疱蜴矧礤镱骢钽糸镱汜祆矧磲泸屮疳铙轱铙鏖翳翳滹趑邃铒翎糸镱矧翳蔑眄镱躺有脲黠蜾ㄥ绠荇堞蝈篝荇堞镳糸镱犰┊盹蝈箫痂轶糸汜翦翦汨铋聃轶躞邃轭翳吞骢钽糸镱犰灬铉踽珏弁赋莓婶轶疱蜴矧礤镱屮痱弩箝镱翳狒栳鲥痫篌殁禊蝈沲蝮轹濠篚豉疱秭弪箦镦狯衢灬忪豉疱螽令屮犴痨鏖祆沆狎殒翳轶狃痱镝汨茆彗轭鲥蜮狒轫ｒ邈豉疱熙弪篚沣镦熙换苠钿鲥蜮狒轫澡蝈沲蝮轹荇熙睚豉疱溴铒翦翳箦镦痫箝糸鲥矧铛祆轭翦珏蝮族汜翳孱溴骈铄骢钽糸镱荇龄潺翳狒泔眇豸弩翳篚镦赭鲠祯弩ㄧ轹孱轭疳轵狎珲礤铘镦豉疱荇熙睚茆彗轭鲥蜮狒轫ｌ弭蝈篚骢弪铿侃篚沣噩侃篚ㄘ篚沣侃换苠钿鲥蜮狒轫澡磲翥栝铉轶疱蜴矧礤镱翳赭豉疱泔铙趄蹉麸蝮荇弪稞犷荇篚沣镦荇熙睚翳轶轶躞踽祆轫痨屙孱翦怡镱瀛麽躅殒殂狒轱蝻豸轭瀹澡礤汨犷轶镦苠鲩鬻簖栳忮孱痱镳矬邃骘磲翥栝铉屮痱弩箝镱翳狒栳鲥犷徕篝蜥泗溽翎豉疱圩阜莓澡轶犰祜黧翳痱镧蜥眄弪麸躞疳趑弪瞽磲翥栝铉鏖翳秕祜箝铉翳徕篝蜥泗轱町描犷玳铉翳轫痨屙孱翎糸镱镦犷徕篝蜥泗溽翎豉疱黠瞌蝈聃轵犷盹溟骈汜糸镱镦痱镧蜥眢翳狒轫痫螋翳轶豉疱翳轶黠蹯漕忮翳汜箦鏖翳翳吞腴钿镦磲翥栝铉麒殂轶泔钽蝈翦┊令屮翦蝾犰蝈箴轭翦蝾犰溴筱蜷痿轱镦犷徕篝蜥泗鲠祯轶玳鲥翳蝻蹒翳狒趄殁豸苠秕酏蝈箴苠轭轭翳溽翎豉疱溴骈铋糸镱骑轭篝犷沐犷轭翦珏汜忮箦孱狍茆彗轭鲥蜮狒轫鲩鬻轭汉阱蝻吁沣轭轭阱蝻殒罱吁沣瞽暴殒秕阱蝻秕ㄓ蹉瞟瞰苠钿鲥蜮狒轫深翳轶屮犴痨瀣翳徕篝蜥泗溴骈铋糸镱镦犷轭翦珏栳泔钽蝈翦溴筱蜷痿轱翳狒轶翳泔蝌弩痫钿轭轭翦珏铛礅弪澡疳趑弪磲翥栝铉轶疱蜴矧礤镱翳轶泔钽蝈翦鲥蝮轱镦翳溽翎豉疱鲩翳徕篝蜥泗骢钽糸镱螽鲥蝙箝黹灬铒糸镱麸秕疳趑弪驷汩扉豉栳忮孱蝈沐铘禊轭趄镤蹉邃轭凼阜莓澡轶狃痱镝汨轶忉箦镱翳狒趄殁豸珧犴磲疳蜥溟珥狃痨殄麸掏态灬鲥蝮轱镦吞蝈沲蝮轹泔铘蝻篝蝓泗躜汜祆邃荇汜箦蝈泯轶轭趄镤蹉邃麸趄狯弪箦泔钽蝈翦溽翎篝蝓泗躜弩犷泔眇豸狒趄殁豸弩翳轶泔铙趄蹉轶泔眇戾铒蝈篝蜷泗邃麸铒瞽汩蜚蹯狎珧犴磲蝮犷麽铒轫痨屙孱翦狒翳狒糸礤契螋桢蝽矧瀣轸蝈扉弩桢狯殪镱翳灬轭弩镦掏箝钽轸滹弩瞌蝈篝蜷泗翳狒趄殁豸弩泔眇豸狒轱轭翳麽秕泔铙趄蹉滹弩渝鲥蜥雉桢篝蹁殄栳鲥犰箫忮孱磲溴轭翳泔铘屮镦徙麸灬铉踽珏螽澡弩灬铉踽珏溴骈铄疳趑弪磲翥栝铉镳弪狒矧狍栝玷弪戾鲥镡赍泗螽箩汶趄徙腴铉轶犰箫犰祜麇轭翳轶筱桢礤麸徙泔盹溽翦泔铙趄衢铘翳狒黹玷忮溴骈铄镱疳趑弪铙テ矧轭篝犷沐篚痧矬ヴ栳轭篝遽镦磲翥栝铉翳骈蝮屐屙孱镦扉篝翳灬篝屐屙孱ラ磲翥桢洚扉箴箝眭灬翦骘蝽镦翳轶屮犴痨轶ボ忮玳铥鲥蜮狒轫エ溴骢骘èó┅ボ孱潲鲥蜮狒轫麒弪翳骢钽糸镱荇忑蝈痱弩孱趔翳灬篝屐屙孱镦扉篝澡ロ狒汨轭轶疱蜴矧礤怡眭祠轲戾鲩箝趔秭弪翳篝蝓泗躜镦翳ャ犰扉铉狎珲礤铘澡轶箦狎汨汜忮篚沣弩箧蹯禊翦蝽轭狒邃矧汜レ遽麸驷殪镱翳篝蝓泗躜镦翳汜祆轭狎珲礤铘荏邈糸镱义沲蝮轹嗅趑弪歪翥栝铉义沲蝮轹疳趑弪磲翥栝铉轶灬铉踽珏轭溴疱钿犷铒糸镱婶汜忮躞邃轭犷骢钽糸镱犰灬铉踽珏翳狒篚痧矧趔篝蝓泗躜邃泔钽蝈翦溽翎豉疱螽荏踱箦泗轱铥赠疱物翎糸镱泔钽蝈翦豉疱荇札汜彘翳弪忮忉箝豉疱扉脲荇深酏矧荇嘛镬矧泔铙趄蹉翦豉疱泔铙趄蹉翦豉疱轶篚镦痱镤蹉豉疱ㄩ瀹溟箨镩铘躅轱铙镦篝蝓泗躜弩鏖翳眭祠轲戾礤礅弪扉脲荇舯涸舨酣圆ぼ糸礤螭猿┊族狍篚礤翳狒遽汨鲠祯镦篚豉疱荇札鏖翳翎荇酏筢糸箧殄翳蝓瞽糸礤痱邃殂狒よ狍苓翎邕荇酏せ翳轶礤犷翳狒翎珞蝈痱弩孱糸铉豉疱螬狎汜蝌殄狎秕钿怡翳躅溴蜢轭轫痨屙孱翎糸镱骑弼弪篚豉疱荇札翳骢钽糸镱苠躅翎琮蝈趄殄鲥翳躅翎珑邃泔眇镱孱镦翳鲠祯瀹骑弼弪痱镤蹉豉疱荇札翳狒栳荇员狍泔眇镱孱衄翳弪屮轶趔骢钽糸镱荇攒咴饼翳狒蝈趄殄鲥翳泔眇镱孱镦豉疱荇员轭犷镡赍泗镦豉疱荇札荏踱箦泗轱铥腻骈铋糸镱镦倚妄澡泔蝈镦翳倚翦汨铋聃轶箴邈獒骘蝽汜祆邃茯痦婶挛簌铘狲轶翳骘祆秣轭绾茆彗轭翎忖轭琮荇蝠睚芙汉荇蝠睚蝻雉渺狨箦荇苘蝻雉芫汉砒痱弩箝镱苘渺狨箦芫汉荇嗅趑弪怙澌荇苘嗅趑弪芫汉荇桢徜礤礅弪荇苘桢徜芫汉射孱糸骈弪苘礤礅弪芫汉射孱糸骈弪苘怙澌芫汉砒痱弩箝镱苠钿翎忖轭琮麒弪苠轸屙蝈痱弩孱趔铒瞽屙痿扉篝镦苠轸屙射孱糸骈弪轶涕箴簌礅镬犷砒痱弩箝镱犷涕箴屮痱弩箝镱义沲蝮轹疳趑弪磲翥栝铉疱蜴矧眢蝈沲蝮轹趄狯弪筢镦趄邋箬狃邃泔钽蝈翦溽翎豉疱澡骢钿犴孱翎汨狎徙翦蜷篝殂镦茯痦轶麸栝溴翳蝈沲蝮轹轭鲲汜糸镱轭箝溴翳鲥蝙溴骈铋糸镱镦翳疳趑弪铙吾礤禊麒孱弼弪礤礅弪狃疱狎轭沆狨箦翳孱轸鲠祯轭翳泔蝌弩痫钿轭怙澌轶翳蝈篚祠镦翳蝈沲蝮轹汜祆镱翳礤礅弪轭篝遽镦翳盹蝈躞踽礤礅弪鲠祯瀹澡轭骘蝽犰箦磲铘殂镦犷茯痦屮痱弩箝镱轶翳骘祆秣轭绠崎蝮衄翳蝻雉屮痱弩箝镱轶弼犰踽翦浠轸鲠祯訾轶篝蝓泗躜邃鲠祯镦豉疱簸麒殂栳麸忮镱镦翳溟骀弪孱桢徜镦翳扉篝镦沆狨箦螽裴汨沆狨箦鏖翳疳趑弪ゐ轶篚沣弩箝鲥禊汨邈脲麸箦麒弭桢簸磲翥桢ゐが楫瀹翳桢徜よ镦ゐ羼踽祗簸澡骈蝮沆狨箦ゃ翳狒篚沣邋潴轶汨矬孱ㄩ铒铄犷弪蝻轶蝈痫螋邃┊澡蝈篚祠镦翳弼犰踽糸镱镦翳扉篝镦屮痱弩箝镱轭箝溴ゃ轭犷狨珥孱翦孱鲩蝻铐孱轶蝈趱蝾邃澡狨珥孱翦孱鲩蝻铐孱轶溴骈铄狍骘祆秣蠛よ轶怙躅麸え躅翎雯犷遽汨礤礅弪ろ轶怙躅麸翳蝈篚祠镦翳蝈沲蝮轹弼犰踽糸镱镦翳麒镬痱镢弩镱翳鲠祯荇à瑜苓ろえ苠躅翎琮訾┅麒弪荇よぼ撙恧轶翳骢钽糸镱翳狒蝈趄殄鲥翳ろ泔眇镱孱镦鲠祯镦豉疱よぎ澡骘蝽犰箦磲铘殂镦茯痦轶玳鲥忮祜鏖翳溴铒翎糸镱犰骒狯矧鏖翳秕祜篌镦珏铄蜥扉豉麇躞邃蝈篝蜷泗邃鲥蝮轱镦茯痦翳狒扉黹趔翳铛礅弪镦沆狨箦麸赭犷犰祜黧镱禊镱礤礅弪轭疳趑弪犷镱屮痱弩箝镱轭遽汨沆狨箦澡篝犷溽蜾溟蝈泗箦磲铘殂ぼ扭镦犷骢钽糸镱犰灬铉踽珏轶屮翦钿邃鏖翳翳箦磲铘殂镦茯痦婶躞弩骢钽糸镱苊翳狒翎脲赭泔铘轭踽糸镱蠛翳骈蝮镱轶躞邃镱沐疳趑弪磲翥桢鏖翳翳鲠祯犷翳箦泔钿镱犰祜黧翳趄獒镦篚怏羼蹂铘沆狨箦矧驷殪躜濠澡箦磲铘殂镦翳疳趑弪磲翥栝铉痱镢弩轶翳骢钽糸镱ぼ肖族玳鲥忮祜翳豉疱镦翳弩骢钽糸镱蠛茆彗轭羼钺蝌狴Ζ芘芘茯殓梏狎蝻郁矧茯殓梏狎蝻义篚祠苘Ζ苊苊荇轫弩苊茯殓梏狎蝻轴祯茯殓梏狎蝻蔑铘茯殓梏狎蝻蔑铘茯殓梏狎蝻郁矧茯殓梏狎蝻义篚祠苘Ζ苄苄狒茯殓梏狎蝻轴祯茯殓梏狎蝻ㄜ射荇轫弩苌溴荇轫弩轴祯濠苘Ζ蔑铘轴祯茯殓梏狎蝻郁矧茯殓梏狎蝻义篚祠苘Ζ义篚祠ㄖ犰蹂茆弪蝻螨苠钿羼钺蝌狴澡箦磲铘殂羼踽糸镱狎翳骘祆秣轭绾茆彗轭翎忖轭琮ぼ跑溻禧蝠帽貌苊茕忪帽貌ㄜ跑溻禧琵螬ㄜ灬礅溽鲶雯ㄜ灬礅溽鲶茆弪蝻螨ぼぼ密溻禧帽貌鲭弑脒搀苊茕忪帽訾芙え莒犴怃鲶苊茕忪帽貌鲭弑脒搀─苘芫え莒犴怃鲶苊茕忪貌雳莒犴怃鲶苊茕忪帽貌鲭弑脒搀ㄜ灬礅溽鲶茆弪蝻螨┅螭苘ぼ密溻禧琵鲭弑脒搀饯芙茯戾酏荇射饼荇射昌苄茕忪旋茯轭ぼ芫茯殒栳筌唪徵啕荇射饼雯茯翳孱芘茕忪琵埯苠躅翎琮霪荇射饼蒇脒ㄡ苠躅翎琮雯蟑荇射昌蒹茯屐箦脒螭苘ぼ熊溻禧ㄉ浔射博荇射饼荇射昌茼怙荇射避呱洳苠钿翎忖轭琮麒弪茼怙荇射避呱洳轶翳骢钽糸镱翳狒蝈趱蝾翳荇射昌礤礅弪镦鲠祯镦豉疱荇射饼物翦翳蝈沲蝮轹忮栳鲩矧镦茯痦痖泗躜邃轭翳躞镦ぼ密溻禧帽貌轭轸秣溴骈铋糸镱荏踱箦泗轱铥倚蔑眇豸弩序轫轸轹义沲蝮轹契钽糸镱簖澡瘐蝠矬镦翳轶箦泗轱轶麸痱秭翳狒翳倚翦汨铋聃栳翳屮痱弩箝鲥痫麇镦痱轫轸轹蝈沲蝮轱町苘苘茴镩钿孱茆腻骈铋糸镱勖阜莓骢钽糸镱ゆ镦狎轸ゎ轶溴骈铄怡苠痱轫轸轹蝈沲蝮轱铨秭弪翳骢钽糸镱ょ犷よ殒犷镱禊殒茆彗轭轸屙辁妪荛翦ゆ弑瞟绋弑哳─殒哳挨荛翦よ弑哳妯弑哳暴雉桢蝼轶苠钿轸屙辁妪茴镩钿孱茆澡屣蝈睚苠令痱轫轸轹蝈沲蝮轹骢钽糸镱汜忮孱泔溴鏖翳茯痦鏖翳秕蝈沲蝮轱町苘苘茴镩钿孱茆序镲纨体荇熙睚忮翳蝈沲蝮轹泔钽蝈翦豉疱荇阱蝻吁沣何蹴体ゆГ忮翳沲蝌殄骢钽糸镱篚汨翳狒ゆЖ哳┄弑啕瞽饼妯弑哳─蛮溴骈铋糸镱麇栳鲥ゆЖ哳莒犴怃弑啕瞽饼绋弑哳─殒哳轶荇阱蝻犷ゆЖ哳莒犴怃弑啕瞽饼瑷弑哳妲┄弑啕瞽饼┅殒哳轶翳篚沣弩箫镦ㄩ瀹茼怙荇熙憝吁沣哳ぉ澡躞怡溴骈铋糸镱镦茯痦茆彗轭翎忖轭琮ゆЖ哳茯痦ぼ饯哳苘芫え荇阱蝻莒犴怃弑啕瞽饼绋弑哳┅苘芫え荇吁沣熙睚莒犴怃弑啕瞽饼瑷弑荇吁沣荇熙睚弑啕瞽饼┅─苠钿翎忖轭琮深箝溴翳怙澌镦翳箦泔钿沆狨箦荇吁沣轶怙躅麸翳沲蝌孱鲠祯镦哳犷荇熙睚溴铒翦翳蝈篚祠镦翳蝈沲蝮轹轭鲲汜糸镱镦ゆГ镱殒茼怙荇熙憝吁沣哳ぎ族汜溴骈铄ゆ轭翳骘祆秣轭麽茆彗轭翎忖轭琮ゆ弑哳ㄜ蝠睨ぼ饯哳苘芫え荇阱蝻莒犴怃弑啕瞽饼绋弑哳┅苘芫え荇吁沣熙睚莒犴怃弑啕瞽饼瑷弑荇吁沣荇熙睚弑啕瞽饼┅─苘芫弑啕瞽饼─苠钿翎忖轭琮澡骘蝽犰痱镲镦羼蹰鲠戾钽忮赭邋翳弩赭骘蝽轶篝蜥殓梏骘蝼狎犷戾骠麸翳蝈徜弪荑骈祆ぼ嘛物翦翳狒麇篚痧矬邃翳狒泔钽蝈翦豉疱麇蝈铒汩蜚蹯狎涉麇蝈灬翳轶蝈篝蜷泗轱ㄩ瀹麇聃轸翳瘐蝈骢钽糸镱犰疳蜥溟珥矧犰祜徕篝蜥泗豉疱轭篝遽镦泔钽蝈翦豉疱蟋翳孱疳螋獒蝈沲蝮轱汜忮孱泔溴鏖翳茯痦澡殇遽轶麸躞翳痫翦铘獒祆轭骈铋翦趄狯弪筢镱汩蜚蹯狎鲠祯麸轫痨屙孱翳黹铋黹狒轱镳弪狒矧镦疳螋獒蝈沲蝮轱町义汜祆翳狒犷蝈沲蝮轹骢钽糸镱ㄩ瀹疳螋獒蝈沲蝮轹濠汜忮泔溴鏖翳泔眇矬轸轱镦骢钽糸镱蟋痱镪邈糸镱蟋痱轫轸轹蝈沲蝮轱犷黹铋黹狒轱町澡躞茯痦泔溴骘犷蝈沲蝮轹骢钽糸镱荏踱箦泗轱铥倚鏖翳眯育倚犰祜黧翳蝈沲蝮轹溴骈铋糸镱镦屮痱弩箝镱麒弪盹蝈翳犷镱狎珲礤铘轶铄邃邃澡趄殂麸徜狃茯痦麸翳轶蝈聃轵屙孱轶麸躞栝玷弪矧溴骢钽糸镱轭麽蝈黹铋筱孱镦翳蔑铘轭踽糸镱嗅篌轭郁戾塾舴份箩箝汜祆遽汨沆狨箦蝈趱蝾骢钽糸镱翳狒轶徕篝蜥泗邃秭弪翳弩狎珲礤铘犷轸轶躔麸翳汜祆弪ㄩ瀹翳痱弼轱躞沆狨箦轭翳澌钺黹汜祆箦聃孱沐麸痱秭殇翳狃痱镳蜷狒疳蜥礤翦鲠祯弩澡轶汜犰箫忮躞邃遽汨糸礤沆狨箦趄遽繇孱蝈聃轵弩箫礤轭桢蜷翦鲠祯弩骝镯轸汜祆弪澡鲥蝙溴骈铋糸镱镦茯痦轶怙趑镯躔犷躞轭翳轶噜眯缨Л扉脲痱镧蜥眄轭疳蜥溟珥轶麽麸箝眭灬翦麸瓠滹黝忮栳鲩矧族骘躅翳轶赭轶鲥蝙篚沣弩箧蹯轭秕痱徙糸汜屮疱蜷礤铘犷遽簌麸躞镱沐狍箝黹灬翦怡痱镧蜥眄弪々荏邈糸镱砒犴痨弩深翳箦聃屐麇鏖祆躞翳蔑眄镱躺有铒翎糸镱痱镤蹉豉疱狎泔溴怡荇溴骟趄蹉酏篚豉疱怡泔蝌弩痫钿轭荇溴骠疱鏖翳犷荇矧泔铙趄蹉麸犷忉箝豉疱怡翳躅溴蜢轭轫痨屙孱翎糸镱族痱弩孱翳蝈箝眇戾屮犴痨弩翳狒躞翳茯痦疳汶徵痱秭殇邃轭翳琉疱钿轼驷泗矧獒骢钽糸镱翳泔眇豸狒轱镦翳骝邋鲠蜷徕戾镦ぼ灬礅溽き屮痱弩箝镱犷提礅溽冕煦蹯躞弼犰踽麸虍荏踱箦泗轱铥漆泗矧獒忑澡泔眇豸狒轱镦翳驷泗矧獒镦犷轭翦珏铛礅弪轶犷屐屙孱翎蝙屮犴痨麒弪翳痫麇镦秕茯痦骢钽糸镱轶箬秣町体躞骈蝮溴骈铄翳豉疱镦轭翦珏铛礅弪犷箫礤骢钽糸镱镱翳屙茆彗轭鲥蜮狒轫ㄤ彐篚铛弪篚沣ㄤ彐痱镤蹉弪铹ㄤ彐痱镤蹉篚沣镦呼疱铛愆ㄤ彐泔铙翎铘铛憝磲脲篚沣猴磲脲弪铹┅ㄤ邈灬蝈ㄦ躅泗轱铛憝痱镤蹉铛铛愆铛愆苠钿鲥蜮狒轫麒弪荇铛睚轶彘翳弪荇弪稞矧荇篚沣鏖翳躅轳蹂礤礅弪荇镦麒殂轶荇铛睚骑泔铞孱殄钽瀣麇溴骈铄荇铛憝饼犷溴沆狎邃翳痱镤蹉骢钽糸镱镱荇铛眢翳泔溴镦麒殂轶戾骠狍犷屮弪汩箦麸翳蝈徜弪┊澡茯痦鲥蝮轱镦驷泗矧獒镱鲠祯弩镦豉疱荇铛睚轶翳骘祆秣轭绾茆彗轭鲥蜮狒轫ㄤ彐躅驷泗矧獒铛愆蝠铛è弪铹铛憝暴è篚沣镦铛憝痱镤蹉篚沣镦┅┅苠钿鲥蜮狒轫麒殂汜忮躞邃轭翳骘祆秣轭麽茆彗轭鲥蜮狒轫ㄦ徙磲脲篚沣猴磲脲篚沣猴磲脲弪铹┅（篚沣（篚沣（弪铹┅苠钿鲥蜮狒轫物翦翳狒躅扉脲雉桢痱镧蜥眄轭翦汨铋聃弩翳弪轶铒屮痨殂轸蝈沲蝮轹汜祆麸荇驷泗矧獒忑轸轶屙忮滗邃轭箝溴翳茯痦磲泸锂荏踱箦泗轱铥乞邋轴蜷徕戾镦提礅溽砒痱弩箝镱簖澡提礅溽冕煦蹯躞磲铋瘐灬翦ぼ灬礅溽き屮痱弩箝镱螽婶簌铘狲轶茆彗轭鲥蜮狒轫ㄤ彐篚灬礅溽屮痱弩箝镱鲠蜷徕戾狃痨殂狒轱徕篝蜥泗轱瞟ㄤ彐痱镤蹉鲠蜷徕戾钺礤呼疱篝蜷铉┅ㄤ彐痱镤蹉狃痨殂狒轱镳弪狒矧呼疱灬礅溽屮痱弩箝镱镳弪犷呼疱灬礅溽屮痱弩箝镱┅ㄤ彐痱镤蹉徕篝蜥泗轱鲠蜷徕戾呼疱鲠蜷徕戾ㄢ镤呼疱灬礅溽屮痱弩箝镱┅ㄤ邈灬蝈ㄦ躅泗轱鲠蜷徕戾鲠蜷徕戾鲠蜷徕戾舂苠钿鲥蜮狒轫ぼ灬礅溽き屮痱弩箝镱轶彘翳弪鲠蜷徕戾犷狃痨殂狒轱镦赭ぼ灬礅溽き屮痱弩箝镱矧犷犷镱盹躞骢钽糸镱鏖翳怙躅鲠蜷徕戾狍骘蝽犰狎珲礤铘犷ぼ灬礅溽き屮痱弩箝镱狍怙澌ㄡ怏趄徙糸镱┊族轭趄镤蹉翳铒糸镱镦骝邋鲠蜷徕戾轭ぼ灬礅溽き屮痱弩箝镱怡篝蝓泗躜犰轭漉泗轱镱翳滹磲轭镦ぼ灬礅溽き屮痱弩箝镱蠛\\
~~\\
\noindent{\bf Definition} [S77] A variable {\tt x} {\em occurs free} in a
$\lambda$-expression {\tt E} if and only if:
\begin{itemize}
\item {\tt E} is {\tt x},
\item {\tt E} is {\tt (E${}_1$ E${}_2$)} and {\tt x} occurs free in
{\tt E${}_1$} or {\tt E${}_2$}
\item {\tt E} is {\tt (lambda V E)}, {\tt x} and {\tt V} are
different and {\tt x} occurs free in {\tt E}
\end{itemize}

\noindent We define the function that computes the set of all free
variables present in a $\lambda$-expression:
\begin{verbatim}
(defun free-variables (expression)
  (rpm expression
       ((variable) `(,variable))
       ((application operand operator)
         `(,@operand ,@operator))
       ((abstraction body)
         (remove (abstraction-variable abstraction) body
                 :test #'variable=))))
\end{verbatim}
Each clause returns a list of variables after applying the
appropriate treatment (e.g., removing the bound variable from the list
of free variables of the body of an abstraction). 

\subsection{A Lambda-Calculus Evaluator}

We will use the previous data type and associated functions to write a
simple evaluator of $\lambda$-expressions. This will be the occasion
of using higher order functions as a means to deal with
arguments; the {\tt evaluate} function takes, beside the expression, 
a {\tt store} that maps variables to {\tt num} values (for instance).

We used the {\tt [} macro character to wrap the special form {\tt funcall}
around the arguments (see Appendix). They wouldn't be required if we
used a one-namespace language like Scheme.

\begin{verbatim}
(defun update-store (value variable store)
  #'(lambda (v)
      (if (variable= v variable)
          value
        [store v])))

(defun evaluate (expression store)
  [(rpm expression
        ((variable)
         #'(lambda (store) [store variable]))
        ((application operand operator)
         #'(lambda (store)
             [[operator store] [operand store]]))
        ((abstraction body)
         #'(lambda (store)
             #'(lambda (value)
                [body (update-store value
                                    (abstraction-variable abstraction)
                                    store)]))))
   store])
\end{verbatim}
The function {\tt update-store} updates the store (which is a function)
to bind the value to the variable. The constant {\tt init-store}
denotes an empty store.  The core function {\tt evaluate} evaluates an
expression in a given store. The key idea is that each clause in the
\rpm\  macro returns a function that maps stores to values. We
give below a simple example that evaluates {\tt ((lambda (x) x) 1)} in
an empty initial store:
\begin{verbatim}
-> (let* ((x (make-variable :name "x"))
          (y (make-variable :name "y"))
          (f (make-abstraction :variable x :body x)))
     (evaluate (make-application :operator f :operand y)
               (update-store num-1 y #'(lambda (variable) :unbound))))

#(succ #(zero))
\end{verbatim}

\section{Future Work}

There are many improvements that can be added to this current
definition of the \rpm\ special form: 
\begin{itemize}
\item
	multiple values could be returned by \rpm. Actually the extended
version of \rpm\ used in the Velour project allows such an extension.
\item
	more general patterns that are not limited to direct
subcomponents could be introduced. For instance, one might want to
perform the recursive calls on specific deeper subtrees instead of
being limited to just a one-level recursion. The implementation
provided in the Appendix includes a limited version of this idea; if a
subcomponent on which a recursive call has to be performed happens to
be a list, the recursive process is mapped on each element of the list
and a list of results is returned. This could also be applied to
vectors.
\item
	a default pattern could be introduced ({\em a la} {\tt \_} of
ML) to trap the values that didn't match any of the clauses.
\end{itemize}

\section{Conclusion}

Recursive Pattern Matching is a programming technique that combines
the advantages of simple pattern matching on structured values and
recursive function definition. It has been widely used in the
development of a vectorizing compiler prototype and proved quite
powerful and useful. 

A portable CommonLISP implementation of \rpm\ is provided. 

\section*{Acknowledgements}

We would like to thank Vincent Dornic for pointing out the quite
relevant paper [J87].

\newpage
\section*{Appendix: A CommonLISP Implementation of \rpm}

\begin{verbatim}
;; The "rpm" (Recursive Pattern Matching) macro package.
;;
;; IMPORTANT NOTE: The rpm macro can only be used on CommonLISP structures
;; that are implemented as named vectors. Use the following declaration
;; for that purpose: (defstruct (foo (:type vector) :named) ...). Without
;; this definition, the rpm package may (or may not) work depending on
;; a particular implementation of structures. We provide DEFSUM and
;; DEFPRODUCT macros that introduce these particular declarations.
;; 
;; This software is provided without any guarantee. Any trouble can be
;; reported to jouvelot@brokaw.lcs.mit.edu or Babak.Dehbonei@crg.bull.fr.
;;
;; Copyright (C) 1989 - Pierre Jouvelot & Babak Dehbonei.

(provide :rpm)
(in-package :rpm)
(export '(rpm defsum defproduct))

(deftype base-type ()
  "The type of values that are self evaluating."
  '(or symbol integer float character string))

(defmacro defproduct (type &rest domains)
  "TYPE is the product domain of DOMAINS"
  `(defstruct (,type (:type vector) :named) ,@domains))

(defmacro defsum (type &rest domains)
  "TYPE is the sum domain of DOMAINS"
  `(deftype ,type '(or ,@domains)))

;; [ ... ] are used to hide funcalls.
;;
(set-macro-character
 #\[
 #'(lambda (stream char)
       `(funcall ,@(read-delimited-list #\] stream t))))
(set-macro-character #\] (get-macro-character #\) nil))

(defmacro rpm (object &rest clauses)
    "To recurse on the value OBJECT with the recursive pattern matching
CLAUSES, use the following syntax:

      (rpm <exp> ((<type> <member1> ... <membern>) <body>) ...)

Inside <body>, <type> is bound to the current value and <memberi> to
to i-th recursive call result of rpm on <type>-<memberi> on the current
Newgen object. If the member is a list, then a list of results is
returned."
    (let ((loop (gensym))
          (obj (gensym)))
        `(labels ((,loop (,obj)
                         (etypecase
                          ,obj
                          (base-type ,obj)
                          (cons (mapcar #',loop ,obj))
                          (vector
                           (cond ,@(rpm-clauses obj clauses loop))))))
             (,loop ,object))))

(defun rpm-clauses (obj clauses loop)
  "Tests all the CLAUSES to find the first one that matches the type of
the value OBJ. The recursive function to use for members is LOOP."
    `(,@(mapcar 
         #'(lambda (clause)
             (let* ((pattern (car clause))
                    (head (car pattern)))
               `((,(intern 
                    (concatenate 'string (symbol-name (intern head)) "-P"))
                  ,obj)
                 (let ((,head ,obj)
                       ,@(recurse-members head obj (cdr pattern) loop))
                   ,@(or (cdr clause)
                         `((declare (ignore ,@pattern))))))))
         clauses)
        (t (error "rpm: unknown value D" ,obj))))

(defun rpm-members (head obj members loop)
  "Creates the bindings of each element of MEMBERS to the return of
the recursive call of LOOP on the MEMBER of OBJ (which is of type HEAD)."
    (mapcar #'(lambda (member)
                `(,member
                  (,loop (,(intern 
                            (concatenate 'string
                                         (symbol-name (intern head))
                                         "-"
                                         (symbol-name (intern member))))
                          ,obj))))
            members))
\end{verbatim}

\section*{References}

\begin{description}
\item[\mbox{[C87]}]
        Cohen, D.E {\em Computability and Logic}. Ellis Horwood,
Halstead Press, J.Wiley and Sons, New York 1987
\item[\mbox{[JW85]}]
        Jensen, K., and Wirth, N. {\em The Pascal User Manual and
Report}. Third Edition, Springer-Verlag, New York 1985
\item[\mbox{[J87]}]
	Johnsson, T. Attribute Grammars as a Functional Programming
Paradigm. In the {\em Proceedings of the 1987 Int. Conf. on Func. Prog.
Lang. and Comp. Arch.}, Portland, 1987
\item[\mbox{[M83]}]
        Milner, R. A Proposal for Standard ML. {\em Polymorphism Letters I},
Bell Labs, 1983.
\item[\mbox{[KR78]}]
        Kernighan, B., and Ritchie, D. {\em The C Programming
Language}. Prentice-Hall, 1978.
\item[\mbox{[S77]}]
        Stoy, J. E. {\em Denotational Semantics: the Scott-Strachey
Approach to Programming Language Theory}. MIT Press, 1977.
\item[\mbox{[St84]}]
        Steele, G. L., Jr. {\em CommonLISP: The Language}. Digital Press, 1984.
\item[\mbox{[St77]}]
        Steele, G.L., Jr. {\em Rabbit}. MS Thesis, MIT AI Lab, 1977
\item[\mbox{[W87]}]
        Wadler, P. Views: A way for pattern matching to cohabit with
data abstraction. In {\em Proceedings of the Conference on Principles
Of Programming Languages}. ACM, Munich, 1987.
\end{description}

\end{sloppypar}
\end{document}

