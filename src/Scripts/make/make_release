#! /bin/sh
#
# $Id$
#
# (c) Fabien COELHO 1996
#

# creates a release, with sources / executables ???
# namely a compressed tar file?

script=`basename $0`

unset name dirs root trgt oths edit files 
tar=${PIPS_TAR:-gtar}
taropt=cf
make=${PIPS_MAKE:-gmake}
verb=:

verbose()
{ echo "$script: $@" >&2;}

error()
{ ret=$1; shift; verbose "$@"; exit $ret;}

usage()
{
    ret=$1; shift
    cat <<-EOF
	$script: $@
	usage: $script [options] dirs...
	 -h: print this help
	 -v: verbose
	 -e: edit list
	 -r dir: Root directory -- absolute!
	 -t dir: Target directory -- idem!
	 -s dir: Source directories -- with release!
	 -d dir: Other directories -- direct!
	 -f file: put file into the release -- direct!
	 -c file: add the contents of file (list of subdirectories/files)
	 dirs: direct directories relative to root -- cleaned!
	EOF
    exit $ret
}

while getopts hver:s:t:d:f:c: opt
do
    case $opt in
	h) usage 0 "some help" ;;
	v) verb=verbose ; taropt=cvf ;;
	e) edit=1 ;;
	r) root=$OPTARG ;;
	s) dirs="$dirs $OPTARG" ;;
	t) trgt=$OPTARG ;;
	d) oths="$oths $OPTARG" ;;
	f) files="$files $OPTARG" ;;
	c) contents="$contents $OPTARG" ;;
	*) error 2 invalid option -$opt ;;
    esac
done

shift `expr $OPTIND - 1`

$verb going to $root
cd $root || error 3 "cannot cd to $root"
test -d $trgt || mkdir $trgt || error 4 "cannot mkdir $trgt"

#
# tmp files

tmp=$trgt/$script.`whoami`.$$
rm -f $tmp.*

$verb in `pwd`

# Sources
for dir in $dirs 
do
    $verb "considering $dir (source)"
    $make --no-print-directory -C $dir \
	FWD_MKFLAGS='--no-print-directory' \
	FWD_ROOT="./$dir" \
	RELEASE_OUT=">> $tmp.tmp" release
    # all Makefiles should be collected...
    find ./$dir -name 'Makefile' -print >> $tmp.tmp
done 

# Direct 
for dir in $oths "$@"
do
    $verb "considering $dir (direct)"
    find ./$dir ! -type d -print >> $tmp.tmp
done

# Very direct 

for f in $files
do
  $verb "consireding file $file (direct)"
  test -r $file && echo $file >> $tmp.tmp
done 

# contents

for c in $contents
do
  $verb "considering file contents $c"
  dn=`dirname $c`
  test -r $contents && {
    for r in `sed /#/d $c`
    do
      $verb "considering $dn/$r"
      test -r $dn/$r && 
	  find $dn/$r \( -type f -o -type l \) -print >> $tmp.tmp
    done 
  }
done

#
# clean the list of file of obviously useless stuff.

sed '/\/OLD/d;/\/SCCS/d;/\/RCS/d;/~/d;/\.database/d;/\.out$/d;/core/d;
     /\.pipsprogram/d;/#/d;/\.old$/d;/\.log$/d;/\.dvi$/d;/\.toc$/d;/\.aux$/d;
     /\/\./d;/Validation\/.*\/pips$/d;/Validation\/.*\/[twf]pips$/d;' \
    $tmp.tmp | sort -u > $tmp.list

rm -f $tmp.tmp

#
# suggest editing the file now

test "$edit" &&
{
    echo "You can edit $tmp.list from $root to your convenience now!"
    echo "press return to continue"
    read x
}

#
# target 

$verb copying files in $trgt
$verb taring and untaring for copy...

# relies on the -T option (from GNU tar),
# otherwise the list of files is just too big to be put as a arg.
# I could forbid OLD and SCCS files, at this level, maybe.
# also symbolic links are dereferenced (-h option)

{ $tar $taropt - -hT $tmp.list || error 5 "tar returned $? while taring" ; } |
( cd $trgt || error 6 "cannot cd to $trgt" ; 
  $tar xf - || error 7 "tar returned $? while untaring" ; ) 

$verb done

#
# cleaning

rm -f $tmp.*

# end of it
#
