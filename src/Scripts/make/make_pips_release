#! /bin/sh
#
# $Id$
#
# (c) Fabien COELHO 1996

unset pack what dotar dozip zip name tostrip strip \
    install addpublic tarname onlyfpips

script=`basename $0`
tar=${PIPS_TAR:-gtar}
taropt=cf
zip=${PIPS_ZIP:-"gzip -v9"}
verb=:
cwd=`pwd`

verbose()
{ echo "$script: $@" >&2;}

error()
{ ret=$1; shift; verbose "$@"; exit $ret;}

usage()
{
    ret=$1
    shift
    cat <<-EOF
	[$script]: $@
	usage: $script [options] name
	  misc:
	    -h: this help
	    -v: verbose
	    -r: add proper installation and readme files in the root
	    -s: strip binaries
	    -t: tar
	    -z: tar and zip
	    -d dir: cd to dir to do the job (eg thru rsh)
	    -f: tar-file name prefix (default name)
	    -w: additional options for make_release
	        (e.g. -w -e to enable manual editing of the list of files)
	  release content:
	    -C: common (Share Doc Examples)
	    -S: add sources (Include, Src [but not Public], Utils)
	    -D dir: add directory dir (Examples?)
	    -F file: add file content (Validation/exportonly?)
	    -B arch: add binaries for arch (Runtime Bin/arch)
	    -L arch: add libraries for arch (Lib/arch)
	    -X: only export fpips (not pips, tpips and wpips)
	  software:
	    -p: Pips
	    -n: Newgen
	    -l: Linear
	    -e: Extern (other softs...)
	    -P: Public (daVinci, toolpack)
	  name: target (a date & content-dependent default is provided)
	EOF
    exit $ret
}

#
# get options

while getopts d:hvrstzw:CSB:L:D:F:f:pnlePX opt
do
    case $opt in
	d) cd $OPTARG ;;
	h) usage 0 some help ;;
	v) verb=verbose ; what="$what -v" ; taropt=cvf ;;
	r) install='1' ;;
	s) strip='strip' ;;
	t) dotar=1 ;;
	z) dotar=1 ; dozip=1 ;;
	w) what="$what $OPTARG" ;;
	C) what="$what -d Share -d Doc -d Examples" ;
	   name="${name}C" ;;
	S) what="$what -s Src -d Include -d Utils" ; 
	   name="${name}S" ;;
	B) what="$what  -d Runtime -d Bin/$OPTARG" ;
	   name="${name}B$OPTARG" ;
	   tostrip="$tostrip Bin/$OPTARG" ;;
	f) tarname="$OPTARG" ;;
	F) what="$what -c $OPTARG" ;;
	L) what="$what -d Lib/$OPTARG" ; name="${name}L$OPTARG" ;;
	D) what="$what -d $OPTARG"  ; name="${name}D" ;;
	p) pack="$pack PIPS" ; name="${name}p" ;;
	n) pack="$pack NEWGEN" ; name="${name}n" ;;
	l) pack="$pack LINEAR" ; name="${name}l" ;;
	e) pack="$pack EXTERN" ; name="${name}e" ;;
	P) addpublic="$TOOLPACK_DIR $DAVINCIHOME" ; name="${name}P" ;;
	X) onlyfpips=1 ;;
	*) usage 1 "invalid option -$opt" ;;
    esac
done

shift `expr $OPTIND - 1 `

# default: //"%H""%M""%S"
name=${1:-pips_${name}_`date +"%y""%m""%d"`}

$verb "target release name: $name"

test -d $name || mkdir $name || error 2 "cannot create directory $name"

#
# get the files

$verb getting ${pack}:
for p in $pack
do
    #
    # set the parameters
    case $p in
	PIPS)   root=$PIPS_ROOT   ; trg=$cwd/$name/Pips   ;;
	NEWGEN) root=$NEWGEN_ROOT ; trg=$cwd/$name/Newgen ;;
	LINEAR) root=$LINEAR_ROOT ; trg=$cwd/$name/Linear ;;
	EXTERN) root=$EXTERN_ROOT ; trg=$cwd/$name/Extern ;;
	TOOLPACK) root=$TOOLPACK_DIR ; trg=$cwd/$name/Toolpack ;;
    esac

    #
    # copy directories
    $verb "packing for $p ($root) in $trg:"
    $verb "what=$what"
    make_release -v -r $root -t $trg $what || 
	error 3 "make_release returned $?"

    #
    # strip if required
    [ "$tostrip" ] && 
    {
	[ "$strip" ] && 
	{
	    $verb stripping binaries
	    for d in $tostrip ; do $strip $trg/$d/* ; done
	}

	if [ "$onlyfpips" ] 
	then
	    $verb keeping fpips only...
	    for d in $tostrip ; do 
		rm -f $trg/$d/pips $trg/$d/[tw]pips ; 
		test -f $trg/$d/fpips || verbose "WARNING, no fpips in $trg/$d"
	    done
	else
	    $verb removing fpips...
	    for d in $tostrip ; do rm -f $trg/$d/fpips ; done
	fi
    }

done


#
# Get public directory in a raw fashion, unstripped any way:
$verb getting raw ${addpublic}:
for p in ${addpublic}
do
    (cd `dirname $p`; $tar cf - `basename $p`) | (cd $cwd/$name; $tar xf -)
done

#
# installation

test "$install" &&
{
    $verb "copying installation software and doc"
    cp ${PIPS_ROOT}/Utils/install_pips $cwd/$name/install_pips
    cp ${PIPS_ROOT}/Utils/install.README $cwd/$name/README
    cp ${PIPS_ROOT}/Utils/install.INSTALL $cwd/$name/INSTALL
}

#
# tar and zip if required

[ "$dotar" ] && 
{
    cd $cwd

    $verb "taring ($tar $taropt $tarname)..."
    $tar $taropt ${tarname:=${name}}.tar ${name} || error 3 "$tar returned $?"
    chmod a+r ${tarname}.tar

    $verb "removing distribution tree"
    rm -rf $name || error 4 "rm returned $?"

    [ "$dozip" ] && 
    {
	$verb "zipping ($zip)..."
	$zip $tarname.tar || error 5 "$zip returned $?"
    }
}

# end of it
#
