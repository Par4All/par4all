#! /bin/sh
#
# $Id$
#
# (c) Fabien COELHO July 1996
#
# changed a lot. it happens that -r does what you expect from it...
# for building pips on installation, do make-pips -b
# type 'make-pips -h' for help.

umask 2
script=`basename $0`
unset sides parts commands dirs libs pips newgen linear msg report where nodoc
verb=':'
dbg=':'
job=${PIPS_MAKE:-gmake}

#
# misc utils

verbose() { echo "$script: $@" >&2 ;}

error() { ret=$1; shift; verbose "$@"; exit $ret;}

#
# check environment

[ "$NEWGEN_ROOT" ] || error 4 "newgen environment not set!"
[ -d "$NEWGEN_ROOT" ] || error 5 "invalid newgen environment!"

[ "$LINEAR_ROOT" ] || error 6 "linear environment not set!"
[ -d "$LINEAR_ROOT" ] || error 7 "invalid linear environment!"

[ "$PIPS_ROOT" ]   || error 8 "pips environment not set!"
[ -d "$PIPS_ROOT" ] || error 9 "invalid pips environment!"

#
# get variables

if [ -f ${PIPS_ROOT}/Include/define_libraries.sh ]
then
    . ${PIPS_ROOT}/Include/define_libraries.sh
else
    # default for bootstraping pips?
    PIPS_ORDERED_LIBS='Scripts dev make'
fi

#
# get options

usage()
{
    ret=$1
    shift
    cat >&2 <<-EOF
	$script: $@
	usage: $script [options] [targets]
	  -h: print this help and exit
	  -v: verbose
	  -g: debug
	  -N: do nothing, print what would be done
	 possible softs
	  -p: Pips (default)
	  -l: Linear
	  -n: Newgen
	  -k: skip the doc
	 possible sides
	  -P: Production (default)
	  -D: Development
	 misc
	  -i: installation (recompile all but the Documentation)
	  -b: build (Production, Pips+Linear+Newgen, recompile)
	  -r: recompile (Production, Pips, clean+recompile)
	  -d dir: specifies a directory
	  -o file: log file to report to (default is /dev/null)
	  -m msg: message
	  -w where: where to redirect output (default is none)
	 targets: make targets to require (e.g. clean all recompile diff...)
	EOF
    exit $ret
}

while getopts hvgNPDplnbirkd:o:m:w: opt
do
    case $opt in
	h) usage 0 "here is some help!" ;;
	v) verb=verbose ;;
	g) dbg=verbose ;;
	N) job="echo $PIPS_MAKE" ;;
	P) sides="$sides ROOT/Src"; msg="P${msg}" ;;
	D) sides="$sides DEVEDIR"; msg="D${msg}" ;;
	p) parts="$parts PIPS" ; pips='1' ;;
	l) parts="$parts LINEAR" ; linear='1' ;;
	n) parts="$parts NEWGEN" ; newgen='1' ;;
	b) commands="$commands recompile" ;
	   parts="NEWGEN LINEAR PIPS" ;
	   sides="ROOT/Src" ;
	   pips='1' ; linear='1' ; newgen='1' ;;
	i) commands="$commands recompile" ;
	   parts="NEWGEN LINEAR PIPS" ;
	   sides="ROOT/Src" ;
	   pips='1' ; linear='1' ; newgen='1' ;
	   nodoc=1 ;;
	k) nodoc=1 ;;
	r) commands="$commands clean recompile" ;
	   parts="PIPS" ;
	   sides="ROOT/Src" ;
	   pips='1' ; linear='1' ; newgen='1' ;;
	o) report="$OPTARG" ;;
	m) msg="$msg[$OPTARG]" ;;
	d) dirs="$dirs $OPTARG" ;;
	w) where="$OPTARG" ;;
	*) usage 2 "invalid option" ;;
    esac
done
shift `expr $OPTIND - 1`

commands="$@ $commands"

#
# defaults:

[ "$sides" ] || { sides="ROOT/Src" ; msg="P$msg" ; }
[ "$parts" ] || { parts="PIPS" ; pips='1' ; }

#
# set up lib directories, including docs or not.

[ "$newgen" ] && 
{ 
    msg="Newgen:$msg";

    [ "$nodoc" ] || libs="$libs $NEWGEN_DOCS"
    libs="$libs $NEWGEN_ORDERED_LIBS";
}

[ "$linear" ] && 
{ 
    msg="Linear:$msg";

    [ "$nodoc" ] || libs="$libs $LINEAR_DOCS"
    libs="$libs $LINEAR_ORDERED_LIBS"; 
}

[ "$pips" ] && 
{
    msg="Pips:$msg";
    [ "$nodoc" ] || libs="$libs $PIPS_DOCS"
    libs="$libs Libs Passes Scripts Runtimes $PIPS_ORDERED_LIBS"; 
}

[ "$report" ] || report=/dev/null

#
# build the directories to visit

$verb "sides=$sides"
$verb "parts=$parts"

for p in $parts ;
do 
    for s in $sides ;
    do
	$verb 'adding $'${p}_$s
	dirs="$dirs "`eval echo '$'${p}_${s}`
    done
done

#
# do the job here

$verb "dirs=$dirs"
$verb "libs=$libs"
$verb "msg=$msg"
$verb "where=$where"
$verb "commands=$commands"

for d in $dirs
do
  $verb "dealing with $d"
  test -d $d || error 3 "no $d directory!" 
  echo $job -C $d FWD_DIRS="$libs" FWD_REPORT=">> $report" FWD_MSG="$msg" \
	FWD_OUT="$where" $commands
  $job -C $d FWD_DIRS="$libs" FWD_REPORT=">> $report" FWD_MSG="$msg" \
	FWD_OUT="$where" $commands
done

$verb "done"

# end of it.
#
