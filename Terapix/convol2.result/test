
Inital code

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= isi-2; i += 1)
      for(j = 1; j <= isj-2; j += 1)
         run_kernel(i, j, isi, isj, new_image, image, kernel);
}
void run_kernel(int i, int j, int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   int ki, kj;
   new_image[i][j] = 0.;
   for(ki = 0; ki <= 2; ki += 1)
      for(kj = 0; kj <= 2; kj += 1)
         
         
         new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
   new_image[i][j] = new_image[i][j]/(3*3);
}

After Inlining

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= isi-2; i += 1)
      for(j = 1; j <= isj-2; j += 1) {
         {
            int ki, kj;
            new_image[i][j] = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            new_image[i][j] = new_image[i][j]/(3*3);
         }
      }
}

After scalarization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= isi-2; i += 1)
      for(j = 1; j <= isj-2; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         new_image[i][j] = __scalar__0;
      }
}

After privatization + loop expansion + tiling

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;

l99997:
   for(i = 0; i <= isi-1; i += 1)
l99998:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l99993:
   for(i = 1; i <= isi-2; i += 1)
l99994:
      for(j = 1; j <= isj-2; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 0; ki <= 2; ki += 1)
l99996:
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         new_image[i][j] = __scalar__0;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int I_0;

l99997:
   for(i = 0; i <= isi-1; i += 1)
l99998:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];
   // PIPS test to adjust loop size to required loop expansion parameter
   if (MOD(isi-2, 126)==0)
      I_0 = isi-2;
   else
      I_0 = isi-2+126-MOD(isi-2, 126);

l99993:
   for(i = 1; i <= I_0; i += 1)
l99994:
      for(j = 1; j <= isj-2; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 0; ki <= 2; ki += 1)
l99996:
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         if (i<=isi-2) 
            new_image[i][j] = __scalar__0;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int I_0, i_t, j_t;

l99997:
   for(i = 0; i <= isi-1; i += 1)
l99998:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];
   // PIPS test to adjust loop size to required loop expansion parameter
   if (MOD(isi-2, 126)==0)
      I_0 = isi-2;
   else
      I_0 = isi-2+126-MOD(isi-2, 126);

l99993:
   for(i_t = 0; i_t <= (-1+I_0)/126; i_t += 1)
      for(j_t = 0; j_t <= (-3+isj)/5; j_t += 1)

         for(i = 1+126*i_t; i <= MIN(I_0, 126+126*i_t); i += 1)
            for(j = 1+5*j_t; j <= MIN(5+5*j_t, -2+isj); j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 0; ki <= 2; ki += 1)
l99996:
                     for(kj = 0; kj <= 2; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[-1+ki+i][-1+kj+j]*kernel[ki][kj];
                  __scalar__0 = __scalar__0/9;
               }
               if (i<=-2+isi) 
                  new_image[i][j] = __scalar__0;
            }
}

After loop normalization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int I_0, i_t, j_t;

l99997:
   for(i = 1; i <= isi; i += 1)
l99998:
      for(j = 1; j <= isj; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];
   // PIPS test to adjust loop size to required loop expansion parameter
   if (MOD(isi-2, 126)==0)
      I_0 = isi-2;
   else
      I_0 = isi-MOD(isi-2, 126)+124;

l99993:
   for(i_t = 1; i_t <= (I_0-1)/126+1; i_t += 1)
l99990:
      for(j_t = 1; j_t <= (isj-3)/5+1; j_t += 1)

l99991:
         for(i = 1; i <= MIN(I_0, 126*i_t)-126*i_t+126; i += 1)
l99992:
            for(j = 1; j <= MIN(5*j_t, isj-2)-5*j_t+5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               if (i+126*i_t-126<=isi-2) 
                  new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
            }
}

After Double Outlining and load - store generation

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int I_0, i_t, j_t;

l99997:
   for(i = 1; i <= isi; i += 1)
l99998:
      for(j = 1; j <= isj; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];
   // PIPS test to adjust loop size to required loop expansion parameter
   if (MOD(isi-2, 126)==0)
      I_0 = isi-2;
   else
      I_0 = isi-MOD(isi-2, 126)+124;

l99993:
   for(i_t = 1; i_t <= (I_0-1)/126+1; i_t += 1)
l99990:
      for(j_t = 1; j_t <= (isj-3)/5+1; j_t += 1)

l99991:         microcode_launcher(isi, isj, I_0, i_t, j_t, image, kernel, new_image);
}
void microcode_launcher(int isi, int isj, int I_0, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 1; i <= MIN(I_0, 126*i_t)-126*i_t+126; i += 1)
l99992:
      for(j = 1; j <= MIN(5*j_t, isj-2)-5*j_t+5; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 1; ki <= 3; ki += 1)
l99996:
               for(kj = 1; kj <= 3; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
            __scalar__0 = __scalar__0/9;
         }
         if (i+126*i_t-126<=isi-2) 
            new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int I_0, i_t, j_t;
   //PIPS generated variable
   float (*P_0)[isi][isj], (*P_1)[3][3], (*P_2)[isi][isj];

l99997:
   for(i = 1; i <= isi; i += 1)
l99998:
      for(j = 1; j <= isj; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];
   // PIPS test to adjust loop size to required loop expansion parameter
   if (MOD(isi-2, 126)==0)
      I_0 = isi-2;
   else
      I_0 = isi-MOD(isi-2, 126)+124;

l99993:
   for(i_t = 1; i_t <= (I_0-1)/126+1; i_t += 1)
l99990:
      for(j_t = 1; j_t <= (isj-3)/5+1; j_t += 1) {
         memalloc(&P_2, sizeof(float[isi][isj])-1+1);
         memalloc(&P_1, sizeof(float[3][3])-1+1);
         memalloc(&P_0, sizeof(float[isi][isj])-1+1);
         memload(image, *P_2, sizeof(float[isi][isj])-1+1);
         memload(kernel, *P_1, sizeof(float[3][3])-1+1);

l99991:         microcode_launcher(isi, isj, I_0, i_t, j_t, *P_2, *P_1, *P_0);
         memstore(new_image, *P_0, sizeof(float[isi][isj])-1+1);
         memfree(*P_2);
         memfree(*P_1);
         memfree(*P_0);
      }
}
void microcode_launcher(int isi, int isj, int I_0, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 1; i <= MIN(I_0, 126*i_t)-126*i_t+126; i += 1)
l99992:      convol_microcode(isi, isj, i, i_t, image, j_t, kernel, new_image);
}
void convol_microcode(int isi, int isj, int i, int i_t, float image[isi][isj], int j_t, float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int j;
l99992:
   for(j = 1; j <= MIN(5*j_t, isj-2)-5*j_t+5; j += 1) {
      {
         int ki, kj;
         __scalar__0 = 0.;
l99995:
         for(ki = 1; ki <= 3; ki += 1)
l99996:
            for(kj = 1; kj <= 3; kj += 1)
               
               
               __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
         __scalar__0 = __scalar__0/9;
      }
      if (i+126*i_t-126<=isi-2) 
         new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
   }
}
