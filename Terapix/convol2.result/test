
Inital code

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1)
         run_kernel(i, j, 512, 512, new_image, image, kernel);
}
void run_kernel(int i, int j, int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   int ki, kj;
   new_image[i][j] = 0.;
   for(ki = 0; ki <= 2; ki += 1)
      for(kj = 0; kj <= 2; kj += 1)
         
         
         new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
   new_image[i][j] = new_image[i][j]/(3*3);
}

After Inlining

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            new_image[i][j] = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            new_image[i][j] = new_image[i][j]/(3*3);
         }
      }
}

After scalarization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         new_image[i][j] = __scalar__0;
      }
}

After privatization + loop expansion

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
l99997:
   for(i = 0; i <= 511; i += 1)
l99998:
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l99993:
   for(i = 1; i <= 630; i += 1)
l99994:
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 0; ki <= 2; ki += 1)
l99996:
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         if (i>=1&&i<=510) 
            new_image[i][j] = __scalar__0;
      }
}

After tiling

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 0; i <= 511; i += 1)
l99998:
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l99993:
   for(i_t = 0; i_t <= 4; i_t += 1)
      for(j_t = 0; j_t <= 101; j_t += 1)

         for(i = 1+126*i_t; i <= 126+126*i_t; i += 1)
            for(j = 1+5*j_t; j <= 5+5*j_t; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 0; ki <= 2; ki += 1)
l99996:
                     for(kj = 0; kj <= 2; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[-1+ki+i][-1+kj+j]*kernel[ki][kj];
                  __scalar__0 = __scalar__0/9;
               }
               if (i>=1&&i<=510) 
                  new_image[i][j] = __scalar__0;
            }
}

After loop normalization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 1; i <= 126; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               if (i+126*i_t-126>=1&&i+126*i_t-126<=510) 
                  new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
            }
}

loop expansion again

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 0; i <= 127; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               if (i>=1&&i<=126)
                  if (i+126*i_t-126>=1&&i+126*i_t-126<=510) 
                     new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
            }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
   //PIPS generated variable
   int L_0, L_1, L_00;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 0; i <= 127; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               L_1 = i>=1&&i<=126;
               L_00 = i+126*i_t-126>=1&&i+126*i_t-126<=510;
               L_0 = L_1?L_00:L_0;
               new_image[i+126*i_t-126][j+5*j_t-5] = L_1&&L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
               ;
            }
}

After Double Outlining and load - store generation

void microcode_launcher(int isi, int isj, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_00, L_0, L_1;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 0; i <= 127; i += 1)
l99992:
      for(j = 1; j <= 5; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 1; ki <= 3; ki += 1)
l99996:
               for(kj = 1; kj <= 3; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
            __scalar__0 = __scalar__0/9;
         }
         L_1 = i>=1&&i<=126;
         L_00 = i+126*i_t-126>=1&&i+126*i_t-126<=510;
         L_0 = L_1?L_00:L_0;
         new_image[i+126*i_t-126][j+5*j_t-5] = L_1&&L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
   //PIPS generated variable
   int L_0, L_1, L_00;
   //PIPS generated variable
   float (*P_0)[isi][isj], (*P_1)[3][3], (*P_2)[isi][isj];
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1) {
         memalloc(&P_2, sizeof(float[isi][isj])-1+1);
         memalloc(&P_1, sizeof(float[3][3])-1+1);
         memalloc(&P_0, sizeof(float[isi][isj])-1+1);
         memload(image, *P_2, sizeof(float[isi][isj])-1+1);
         memload(kernel, *P_1, sizeof(float[3][3])-1+1);
         memload(new_image, *P_0, sizeof(float[isi][isj])-1+1);

l99991:         microcode_launcher(isi, isj, i_t, j_t, *P_2, *P_1, *P_0);
         memstore(new_image, *P_0, sizeof(float[isi][isj])-1+1);
         memfree(*P_2);
         memfree(*P_1);
         memfree(*P_0);
      }
}
void microcode_launcher(int isi, int isj, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_00, L_0, L_1;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 0; i <= 127; i += 1)
l99992:      convol_microcode(isi, isj, i, i_t, image, j_t, kernel, new_image);
}
void convol_microcode(int isi, int isj, int i, int i_t, float image[isi][isj], int j_t, float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_0, L_00, L_1;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int j;
l99992:
   for(j = 1; j <= 5; j += 1) {
      {
         int ki, kj;
         __scalar__0 = 0.;
l99995:
         for(ki = 1; ki <= 3; ki += 1)
l99996:
            for(kj = 1; kj <= 3; kj += 1)
               
               
               __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
         __scalar__0 = __scalar__0/9;
      }
      L_1 = i>=1&&i<=126;
      L_00 = i+126*i_t-126>=1&&i+126*i_t-126<=510;
      L_0 = L_1?L_00:L_0;
      new_image[i+126*i_t-126][j+5*j_t-5] = L_1&&L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
   }
}
