
POINTS-TO


// Points To IN: none


// Points To OUT:
// *HEAP*_l_17.next -> *HEAP*_l_17 , MAY
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// initialize -> *HEAP*_l_17 , MAY
// initialize -> *NULL_POINTER* , MAY

list * initialize()
{

// Points To: none

   list *first = (void *) 0, *previous = (void *) 0;

// Points To:
// first -> *NULL_POINTER* , EXACT
// previous -> *NULL_POINTER* , EXACT

   _Bool break_p = 0;

// Points To:
// first -> *NULL_POINTER* , EXACT
// previous -> *NULL_POINTER* , EXACT

   // added to avoid an untructured...
   while (!feof(stdin)&&!break_p) {

// Points To:
// *HEAP*_l_17.next -> *HEAP*_l_17 , MAY
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      list *nl = (list *) malloc(sizeof(list));

// Points To:
// *HEAP*_l_17.next -> *HEAP*_l_17 , MAY
// *HEAP*_l_17.next -> undefined , MAY
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      nl->next = (void *) 0;

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      if (scanf("%d", &nl->val)!=1)

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

         break_p = 1;

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      if (first==(void *) 0)

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *NULL_POINTER* , EXACT
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

         first = nl;

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      if (previous!=(void *) 0)

// Points To:
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY

         previous->next = nl;

// Points To:
// *HEAP*_l_17.next -> *HEAP*_l_17 , MAY
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// nl -> *HEAP*_l_17 , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

      previous = nl;
   }

// Points To:
// *HEAP*_l_17.next -> *HEAP*_l_17 , MAY
// *HEAP*_l_17.next -> *NULL_POINTER* , MAY
// first -> *HEAP*_l_17 , MAY
// first -> *NULL_POINTER* , MAY
// previous -> *HEAP*_l_17 , MAY
// previous -> *NULL_POINTER* , MAY

   return first;
}

PROPER EFFECTS WITH POINTS TO

list * initialize()
{
//             <    is written>: first previous
   list *first = (void *) 0, *previous = (void *) 0;
//             <    is written>: break_p
   _Bool break_p = 0;
//             <may be read   >: stdin[0]
//             <may be written>: stdin[0]
//             <    is read   >: break_p stdin __IO_EFFECTS:LUNS[0]
//             <    is written>: __IO_EFFECTS:LUNS[0]
   // added to avoid an untructured...
   while (!feof(stdin)&&!break_p) {
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: nl _MALLOC_EFFECTS:_MALLOC_
      list *nl = (list *) malloc(sizeof(list));
//             <may be written>: *HEAP*_l_17.next
//             <    is read   >: nl
      nl->next = (void *) 0;
//             <may be read   >: stdin[0]
//             <may be written>: *HEAP*_l_17.val stdin[0]
//             <    is read   >: nl stdin __IO_EFFECTS:LUNS[0]
//             <    is written>: __IO_EFFECTS:LUNS[0]
      if (scanf("%d", &nl->val)!=1)
//             <    is written>: break_p
         break_p = 1;
//             <    is read   >: first
      if (first==(void *) 0)
//             <    is read   >: nl
//             <    is written>: first
         first = nl;
//             <    is read   >: previous
      if (previous!=(void *) 0)
//             <may be written>: *HEAP*_l_17.next
//             <    is read   >: nl previous
         previous->next = nl;
//             <    is read   >: nl
//             <    is written>: previous
      previous = nl;
   }
//             <    is read   >: first
   return first;
}
