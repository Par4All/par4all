Select some options to deal with the C Language:
Parse as C:
Prettyprint the source as C, of course
Do not display original number lines as comment:
If possible, transform simple for-loops into do-loop à la Fortran, simpler to analyze:
Desugaring other for-loops into plain while-loops fot the time we improve semantics ameliorations in PIPS:
Select the most precise analysis:
Compute the intraprocedural preconditions at the same time as
transformers and use them to improve the accuracy of expression
and statement transformers:
Try to restructure the code for more precision:
Privatize scalar variables on all the modules of the program:
Ask for some statistics about the job to be done:
Ask for the parallelization of all the modules of the program with OpenMP output:
main(int argc, char *argv[])
{
   // BEGIN BLOCK

   int l, m, a;

   l = 0;
   while (l<M) {
      // BEGIN BLOCK
compute:      do {
         // BEGIN BLOCK
         m = 0;
         while (m<M) {
            // BEGIN BLOCK
            a = 0;
            l++;
            // END BLOCK
         }
         // END BLOCK
      }
      while (0);
      l++;
      // END BLOCK
   }
   // END BLOCK
}
Regenerate the sources from the PIPS transformed code:
/*
 * file for compute.c
 */
// BEGIN BLOCK
//
//     This module was automatically generated by PIPS
//
void compute(int a, int l, int m);
// END BLOCK
void compute(int a, int l, int m)
{
   // BEGIN BLOCK
   // BEGIN BLOCK
compute:   do {
      // BEGIN BLOCK
      // BEGIN BLOCK
      m = 0;
      while (m<M) {
         // BEGIN BLOCK
         // BEGIN BLOCK
         a = 0;
         l++;
         // END BLOCK
      }
      // END BLOCK
   }
   while (0);
   // END BLOCK
}
/*
 * file for for_to_while03.c
 */
// BEGIN BLOCK
enum {M=64};


extern  main(int argc, char *argv[]);
// END BLOCK
main(int argc, char *argv[])
{
   // BEGIN BLOCK

   int l, m, a;

   l = 0;
   while (l<M) {
      // BEGIN BLOCK
compute:      compute(a, l, m);
      l++;
      // END BLOCK
   }
   // END BLOCK
}
