
Initial code

void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
loop0:
   for(i = 0; i <= 2; i += 1)
loop1:
      for(j = 0; j <= 2; j += 1) {
         c[i][j] = 0;
loop2:
         for(k = 0; k <= 2; k += 1)
            c[i][j] = c[i][j]+a[i][k]*b[k][j];
      }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1];
loop0:
   for(i = 0; i <= 2; i += 1)
loop1:
      for(j = 0; j <= 2; j += 1) {
         c[i][j] = 0;
         for(k = 0; k <= 2; k += 1)
            RED[k] = 0;
loop2:
         for(k = 0; k <= 2; k += 1)
            RED[k] = RED[k]+a[i][k]*b[k][j];
         for(k = 0; k <= 2; k += 1)
            c[i][j] = c[i][j]+RED[k];
      }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1];
loop0:
   for(i = 0; i <= 2; i += 1)
loop1:
      for(j = 0; j <= 2; j += 1) {
         c[i][j] = 0;
         for(k = 0; k <= 2; k += 1)
            RED[k] = 0;
loop2:
         for(k = 0; k <= 2; k += 1)
            RED[k] = RED[k]+a[i][k]*b[k][j];
         for(k = 0; k <= 2; k += 1)
            c[i][j] = c[i][j]+RED[k];
      }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1];
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][0];
      RED[1] = RED[1]+a[i][1]*b[1][0];
      RED[2] = RED[2]+a[i][2]*b[2][0];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][1];
      RED[1] = RED[1]+a[i][1]*b[1][1];
      RED[2] = RED[2]+a[i][2]*b[2][1];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][2];
      RED[1] = RED[1]+a[i][1]*b[1][2];
      RED[2] = RED[2]+a[i][2]*b[2][2];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1];
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][0];
      RED[1] = RED[1]+a[i][1]*b[1][0];
      RED[2] = RED[2]+a[i][2]*b[2][0];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][1];
      RED[1] = RED[1]+a[i][1]*b[1][1];
      RED[2] = RED[2]+a[i][2]*b[2][1];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      RED[0] = RED[0]+a[i][0]*b[0][2];
      RED[1] = RED[1]+a[i][1]*b[1][2];
      RED[2] = RED[2]+a[i][2]*b[2][2];
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1], F_0, F_1, F_2, F_3, F_4, F_5, F_6, F_7, F_8;
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_0 = a[i][0]*b[0][0];
      RED[0] = RED[0]+F_0;
      F_1 = a[i][1]*b[1][0];
      RED[1] = RED[1]+F_1;
      F_2 = a[i][2]*b[2][0];
      RED[2] = RED[2]+F_2;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_3 = a[i][0]*b[0][1];
      RED[0] = RED[0]+F_3;
      F_4 = a[i][1]*b[1][1];
      RED[1] = RED[1]+F_4;
      F_5 = a[i][2]*b[2][1];
      RED[2] = RED[2]+F_5;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_6 = a[i][0]*b[0][2];
      RED[0] = RED[0]+F_6;
      F_7 = a[i][1]*b[1][2];
      RED[1] = RED[1]+F_7;
      F_8 = a[i][2]*b[2][2];
      RED[2] = RED[2]+F_8;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1], F_0, F_1, F_2, F_3, F_4, F_5, F_6, F_7, F_8, F_80, F_70, F_60, F_50, F_40, F_30, F_20, F_10, F_00;
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_00 = a[i][0]*b[0][0];
      RED[0] = RED[0]+F_00;
      F_10 = a[i][1]*b[1][0];
      RED[1] = RED[1]+F_10;
      F_20 = a[i][2]*b[2][0];
      RED[2] = RED[2]+F_20;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_30 = a[i][0]*b[0][1];
      RED[0] = RED[0]+F_30;
      F_40 = a[i][1]*b[1][1];
      RED[1] = RED[1]+F_40;
      F_50 = a[i][2]*b[2][1];
      RED[2] = RED[2]+F_50;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      F_60 = a[i][0]*b[0][2];
      RED[0] = RED[0]+F_60;
      F_70 = a[i][1]*b[1][2];
      RED[1] = RED[1]+F_70;
      F_80 = a[i][2]*b[2][2];
      RED[2] = RED[2]+F_80;
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}

simdized code

void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1], F_0, F_1, F_2, F_3, F_4, F_5, F_6, F_7, F_8, F_80, F_70, F_60, F_50, F_40, F_30, F_20, F_10, F_00;
   //PIPS:SAC generated variable
   overloaded PADDING_VALUE;
   //PIPS:SAC generated float vector(s)
   float v4sf_vec0[3+1], v4sf_vec1[3+1], v4sf_vec2[3+1], v4sf_vec3[3+1], v4sf_vec4[3+1], v4sf_vec5[3+1], v4sf_vec6[3+1], v4sf_vec7[3+1], v4sf_vec8[3+1], v4sf_vec9[3+1], v4sf_vec10[3+1], v4sf_vec11[3+1], v4sf_vec12[3+1], v4sf_vec13[3+1], v4sf_vec14[3+1];
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec2, b[0][0], b[1][0], b[2][0], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec1, &a[i][0]);
      SIMD_MULPS(v4sf_vec0, v4sf_vec1, v4sf_vec2);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec0, &F_00, &F_10, &F_20, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec3, &RED[0]);
      SIMD_ADDPS(v4sf_vec3, v4sf_vec3, v4sf_vec0);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec3, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec7, b[0][1], b[1][1], b[2][1], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec6, &a[i][0]);
      SIMD_MULPS(v4sf_vec5, v4sf_vec6, v4sf_vec7);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec5, &F_30, &F_40, &F_50, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec8, &RED[0]);
      SIMD_ADDPS(v4sf_vec8, v4sf_vec8, v4sf_vec5);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec8, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec12, b[0][2], b[1][2], b[2][2], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec11, &a[i][0]);
      SIMD_MULPS(v4sf_vec10, v4sf_vec11, v4sf_vec12);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec10, &F_60, &F_70, &F_80, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec13, &RED[0]);
      SIMD_ADDPS(v4sf_vec13, v4sf_vec13, v4sf_vec10);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec13, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}
void Matrix_Mult(float a[3][3], float b[3][3], float c[3][3])
{
   int i, j, k;
   //PIPS generated variable
   float RED[2+1], F_0, F_1, F_2, F_3, F_4, F_5, F_6, F_7, F_8, F_80, F_70, F_60, F_50, F_40, F_30, F_20, F_10, F_00;
   //PIPS:SAC generated variable
   overloaded PADDING_VALUE;
   //PIPS:SAC generated float vector(s)
   float v4sf_vec0[3+1], v4sf_vec1[3+1], v4sf_vec2[3+1], v4sf_vec3[3+1], v4sf_vec4[3+1], v4sf_vec5[3+1], v4sf_vec6[3+1], v4sf_vec7[3+1], v4sf_vec8[3+1], v4sf_vec9[3+1], v4sf_vec10[3+1], v4sf_vec11[3+1], v4sf_vec12[3+1], v4sf_vec13[3+1], v4sf_vec14[3+1];
loop0:
   for(i = 0; i <= 2; i += 1) {
loop1:      ;
      c[i][0] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec2, b[0][0], b[1][0], b[2][0], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec1, &a[i][0]);
      SIMD_MULPS(v4sf_vec0, v4sf_vec1, v4sf_vec2);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec0, &F_00, &F_10, &F_20, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec3, &RED[0]);
      SIMD_ADDPS(v4sf_vec3, v4sf_vec3, v4sf_vec0);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec3, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][0] = c[i][0]+RED[k];
      c[i][1] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec7, b[0][1], b[1][1], b[2][1], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec6, &a[i][0]);
      SIMD_MULPS(v4sf_vec5, v4sf_vec6, v4sf_vec7);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec5, &F_30, &F_40, &F_50, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec8, &RED[0]);
      SIMD_ADDPS(v4sf_vec8, v4sf_vec8, v4sf_vec5);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec8, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][1] = c[i][1]+RED[k];
      c[i][2] = 0;
      for(k = 0; k <= 2; k += 1)
         RED[k] = 0;
      SIMD_LOAD_GENERIC_V4SF(v4sf_vec12, b[0][2], b[1][2], b[2][2], PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec11, &a[i][0]);
      SIMD_MULPS(v4sf_vec10, v4sf_vec11, v4sf_vec12);
      SIMD_SAVE_GENERIC_V4SF(v4sf_vec10, &F_60, &F_70, &F_80, &PADDING_VALUE);
      SIMD_LOAD_V4SF(v4sf_vec13, &RED[0]);
      SIMD_ADDPS(v4sf_vec13, v4sf_vec13, v4sf_vec10);
      SIMD_MASKED_SAVE_V4SF(v4sf_vec13, &RED[0]);
      k = 3;
      for(k = 0; k <= 2; k += 1)
         c[i][2] = c[i][2]+RED[k];
      j = 3;
   }
}
seq-ok
sse-ok
