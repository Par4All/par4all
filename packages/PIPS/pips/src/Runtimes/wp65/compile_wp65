#! /bin/sh
#
# $Id$
#
# Copyright 1989-2014 MINES ParisTech
#
# This file is part of PIPS.
#
# PIPS is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# PIPS is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PIPS.  If not, see <http://www.gnu.org/licenses/>.
#

#
# from csh to sh, FC 19/09/95
#

unset erreur target DIR
noise=silent
debug=':'
script=`basename $0`

usage()
{
  cat >&2 <<-EOF
	$script (version $Revision$) [-svhd] [-t name] files.{f,bank,wp65}|dir
	  compile and link a program generated by WP65
	  -t name: target name for the pvm executable (a default is provided)
	  -s: silent (default)
	  -v: verbose
	  -d: debug
	  -h: help
	EOF
  exit ${1:-1}
}

# 

while getopts svhdt: opt
do
  case $opt in
    t) target=$OPTARG ;;
    s) noise='silent' ;;
    v) noise='verbose' ;;
    d) debug='debug' ;;
    h) usage 0 ;;
    *) usage ;;
  esac
done

shift `expr $OPTIND - 1`

#
# Ronan checks that everything is okay! (I agree:-)
# He could have written everything in English instead of French...

[ $# -eq 0 ] && usage 2

[ $noise = verbose -a ! "$PVM_ROOT" ] && 
{
  cat << USAGE

  Penser à initialiser la variable PVM_ROOT avant de lancer
  le programme compilé...

USAGE
  erreur=1
}

[ $noise = verbose -a ! "$PVM_ARCH" ] &&
{
  cat << USAGE

  Avez-vous fait un « source \$PVM_ROOT/lib/cshrc.stub » 
  dans votre environnement ?
  Pensez à mettre aussi « \$PVM_ROOT/lib » dans votre chemin d'accès
  si ce n'est pas déjà fait.

USAGE
  erreur=1
}

[ "$erreur" ] && exit 1

[ -f model.rc ] || echo "$script: warning, no local model.rc" >&2

#
# get the files...

if [ -d "$1" ] 
then
  DIR=`basename $1 .database/`.database
else
  if [ -d "$1.database" ] 
  then
    DIR="$1.database"
  fi
fi

if [ "$DIR" ] 
then
  FILES=`echo $DIR/*.bank $DIR/*.wp65`
  target=`basename $DIR .database`_wp65
else
  FILES="$@"
fi

#
# find some name for the target...

[ "$target" ] ||
{
  basef=`basename $1 .f`
  baseb=`basename $basef .bank`
  basew=`basename $baseb .wp65`
  target="$basew"_wp65
}

#
# Let's compile

WP65_RUNTIME=${WP65_RUNTIME:-${PIPS_ROOT}/Runtime/wp65}
export WP65_RUNTIME 

TMP=wp65_tmp_$$

sed 's,DOALL ,DO ,;/PRIVATE /d' $FILES > $TMP.f
${PIPS_MAKE:-gmake} -f $WP65_RUNTIME/Makefile.compile_wp65 \
	SOURCES.f="$TMP.f" CIBLE="$target"
status=$?

[ $debug = ':' ] && rm -f $TMP.f $TMP.o

[ $noise = verbose -a "$status" -ne 0 ] &&
{
  cat << USAGE

Vous pouvez lancer pvm dans une fenêtre si ce n'est pas déjà fait 
et lancer votre programme « `echo $1 | sed 's/.f\$//'` ».

Dans le shell pvm,
 - « add » permet de rajouter une liste une machines ;
 - « conf » affiche les machines utilisées ;
 - « ps -a » affiche les processus en cours ;
 - « reset » arrête les processus en cours ;
 - « quit » sort du shell pvm mais laisse pvmd tourner ainsi que
   les processus. On y revient en relançant pvm.
 - « halt » fait le ménage complet.

 Pour mettre au point, utilisez la variable LANCEWP65_DEBUG_LEVEL
 avec comme valeur :
   2 : affiche les tids des processus lancés ;
   3 : ouvre autant de xterm avec gdb que de processus ;
   4 : affiche les messages échangés entre bancs et PEs ;
   5 : idem que 4 avec les tids en plus et les morceaux de message.
USAGE
}
