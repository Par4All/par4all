\documentclass[a4paper]{article}
\usepackage[latin9]{inputenc}
\usepackage{url}
\usepackage{alltt}
\usepackage{abbrev_reactive}
\let\OldRightarrow=\Rightarrow
\RequirePackage{marvosym}
\let\MarvosymRightarrow=\Rightarrow
\let\Rightarrow=\OldRightarrow
\RequirePackage{wasysym}
\let\Lightning\UnTrucIndefini% Car conflit entre ifsym et marvosym
\let\Sun\UnTrucIndefini%
\RequirePackage[weather]{ifsym}


\sloppy

\begin{document}

\title{Par4All organization\\
  \textsc{draft}\\
  ---\\
  HPC Project}

\author{Serge \textsc{Guelton} \and Ronan \textsc{Keryell} \and Grégoire
  \textsc{Péan} \and Claire \textsc{Seguin} \and Mickaël \textsc{Thievent}
  \and Pierre \textsc{Villalon}}

\maketitle


\section{Introduction}
\label{sec:introduction}

\Apfa is a platform that merges various open source developments
to aim at achieving the migration of software to multicore and other
parallel processors.

It is mainly developed by \Ahpcp, MINES ParisTech/\Acri, Institut
Télécom/Télécom Bretagne and others.

This document describes the internal organization of \Apfa and how its
construction relies on \Agit repositories, \Asvn repositories and other
projects.

Since it relies on other tool projects, the documentation of these other
projects should also be taken into account.

Before using \Apips, once it is installed, you should do, according to your
shell, a
\begin{verbatim}
source run/etc/par4all-rc.sh
\end{verbatim}
or a
\begin{verbatim}
source run/etc/par4all-rc.csh
\end{verbatim}


\section{Compilation}
\label{sec:compilation}

Once you have an image of the main \Agit repository content, \Apfa is
compiled and configured by running \verb|src/dev/p4a_setup|.

If you want to download \Apfa from the \Agit and compile it, try:
\begin{alltt}
  export P4A_ROOT=\emph{some-dir}
  git clone git://git.hpc-project.com/git/par4all.git $P4A_ROOT
  cd $P4A_ROOT
  git checkout -b p4a remotes/origin/p4a
  src/dev/p4a_setup
\end{alltt}%$
Everything is built into \verb|$P4A_ROOT/build| and installed into
\verb|$P4A_ROOT/run|.

To be sure you do not break the compilation process, you should compile
your work before committing it on the central repositories. By a nice side
effect, it allows you to test your code. \smiley

More seriously, it is not obvious that it may compile on your account but
not for other people. For example because you forgot to commit some files.

A nice feature of \Agit over \Asvn is that since you split the commit from
the publication, you can test your own committed state before it hurts the
team when you push it on the global server.

For example, you can create a light\footnote{Because the objects are
  shared with symbolic links and not copied since we did not use the
  \texttt{file://} syntax.} clone with a
\begin{verbatim}
git clone par4all par4all-compile
\end{verbatim}
and after you have tested and committed your modifications inside the
\texttt{par4all} working copy, you do the same into the
\texttt{par4all-compile} working copy after a \texttt{git pull}.
If some files are lacking from the commit, it will be detected.

Afterwards you can do a \texttt{git push} into the central \Apfa
repository with less risks.


\section{Collaborative repositories}
\label{sec:coll-repos}


\subsection{Public repositories}
\label{sec:public-repositories}

There are few \Agit repositories used by the project.

To have access without authentication and only for reading/cloning, you
can use the \texttt{git:} prefix instead of \texttt{ssh:}, such as
\url{git://git.hpc-project.com/git/par4all.git}.

The main repository for the project is:
\url{ssh://git.hpc-project.com/git/par4all.git}

It can be seen with a \Awww browser at
\url{https://git.hpc-project.com/cgit/par4all}

To get directly involved into the project with full commit right in the
repositories, ask \Ahpcp.

There are also ancillary \Agit repositories to offer a \Agit interface to
the trunk of the \Asvn repositories for the \Apips components from \Acri:
\begin{itemize}
\item \url{ssh://git.hpc-project.com/git/svn-linear.git}
\item \url{ssh://git.hpc-project.com/git/svn-newgen.git}
\item \url{ssh://git.hpc-project.com/git/svn-nlpmake.git}
\item \url{ssh://git.hpc-project.com/git/svn-pips.git}
\item \url{ssh://git.hpc-project.com/git/svn-validation.git}
\end{itemize}
These ancillary gateways only include the \texttt{trunk} history since at
\Acri branches are not public.

In the case of \texttt{nlpmake}, another \Agit{} \Asvn gateway of the top
level has been used for the integration (but is not published in a public
git because it is old history) with \texttt{trunk}, \texttt{branch} and
\texttt{tag} because \texttt{nlpmake} started without this standard
layout, that was added later around revision 750.


\subsection{Private repositories}
\label{sec:private-repositories}

There is a private directory shared between core developers used mainly
for validation of the project on non public codes, benchmarks, demos, for
developing private reports, phases, scripts and so on:
\url{ssh://git.hpc-project.com/git/par4all-private.git}

For \Ahpcp-confidential information,
\url{ssh://git.hpc-project.com/git/par4all-private-hpc.git} is used.

According to the evolving private collaborations, other repositories can
be created and used on demand.


\section{Packages}
\label{sec:packages}

\Apfa integrate different tools from different projects. Right now \Apfa
is composed by \Apips, \Apipsgfc, \Apolylib, with some extensions. Each
project is included in \Apfa as a package and is placed in a directory
inside the \texttt{package} top-level directory.


\section{Directory organization}
\label{sec:direct-organ}

\begin{description}
\item[\texttt{build}] is the directory created with the various productions
  of the compilation of all the \Apfa packages: binaries, header files,
  documentation;
  \marginpar{Right now it is still mainly in \texttt{package/PIPS} since
    I'm waiting for the new \Apips compilation infrastructure. RK}
  \begin{description}
  \item[\texttt{bin}] contains the executable programs from \Apfa;
  \item[\texttt{doc}] is the generated documentation for the \Apfa
    infrastructure;
  \item[\texttt{etc}] contains some generated configuration files;
  \item[\texttt{include}] contains the include files used for the
    compilation of \Apfa;
  \item[\texttt{lib}] owns the libraries used to run \Apfa;
  \item[\texttt{share}] contains shared files for run-time and
    configuration files

    \marginpar{what is the difference of this \texttt{pipsrc.sh} and the one in
      \texttt{etc}? \texttt{RK->FC}}

  \item[\texttt{utils}] gathers various utility programs used by \Apfa
    infrastructure (validation...) and other internal tools;
  \end{description}
\item[\texttt{doc}] are the sources of the \Apfa infrastructure;
\item[\texttt{examples}] comes with some examples to exercise \Apfa;
\item[\texttt{packages}] contains the different components of \Apfa; of
  all the \Apfa packages: binaries, header files, documentation;
  \begin{description}
  \item[\texttt{PIPS}] contains the components of \Apips framework itself
    with
    \begin{description}
    \item[\texttt{linear}] is the \Apips linear library of \Apips;
    \item[\texttt{newgen}] is the object management infrastructure used by
      \Apips;
    \item[\texttt{nlpmake}] is the makefile common infrastructure used by
      all the \Apips components
    \item[\texttt{pips}] is the \Apips core;
    \item[\texttt{validation}] is the validation of \Apips
    \end{description}
  \item[\texttt{pips-gfc}] contains a \Agcc 4.4 source patched to be
    compiled and linked with \Apips to add a Fortran 95+ parser to \Apips;
  \item[\texttt{polylib}] contains the \Apolylib library source
  \end{description}
\item[\texttt{src}] contains source of tools used for the internal
  organization of \Apfa itself, such as repository and product management,
  publication process.
\end{description}


\section{Repositories and work-flow}
\label{sec:repos-workfl}

For history tracking and collaborative development, \Apfa relies on a main
\Agit repository that is accessed by \Apfa developers, users, integrators
and the product and quality team.

The script \verb|p4a_git| is used to automate the management of the
workflow.

Since \Apfa intimately extends some tools such as \Apips, their are some
ancillary repositories to ease the impedance matching between \Apfa and
those other project.

Since \Apolylib is already a \Agit repository, it is simply fetched as a
remote \Agit into the \Apfa at the right place.

But this is far more complex with \Apips which is a project split in 5
independent \Asvn repositories, so its organization needs more massage to
be presented in a coherent way, with some \Asvn-\Agit gateways. We can
take advantage of these gateways to offer more free developments with
light branches stored into a common \Agit view of the \Apips{} \Asvn
repositories that can be pushed back into the \Apips{} \Asvn .


\subsection{The p4a\_git script to deal with workflow}
\label{sec:p4a_git-script-deal}

The \verb|p4a_git| is used to manage the workflow of \Apfa involving all
the related \Agit and \Asvn repositories.

Do not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback. Have a look to the \texttt{git reset} documentation to undo
things if things go wrong.

Some commands of \verb|p4a_git| need to have the \verb|P4A_TOP|
environment variable defined to the top directory of the \Apfa
infrastructure that owns the various \Agit working copies involved in the
project.

The \verb|p4a_git| options come into short and long form:
\begin{description}
\item[\texttt{-h} or \texttt{--help}] display the usual help message;
\item[\texttt{-v} or \texttt{--verbose}] increase the verbosity of the
  script. For example, if used twice, the script enters into command
  tracing mode;
\item[\texttt{-u} or \texttt{--update-git-svn}] update the \Apips{}
  \Agit-\Asvn gateways that are into \verb|$P4A_TOP/CRI-git-svn|;%$
\item[\texttt{-g} or \texttt{--recursive-git-svn}] apply a \Agit command
  to all the git working copies inside the current directory
  recursively. If no argument is given, a \texttt{git svn rebase} is done;
\item[\texttt{-f} or \texttt{--fetch-remote-git}] fetch the objects from
  the remote \Agit repositories (the \Apips{} \Agit-\Asvn gateways and the
  \Apolylib{} \Agit);
\item[\texttt{-p} or \texttt{--pull-remote-git}] pull the objects from the
  remote \Agit repositories into their respective branches and update the
  \texttt{p4a} branch hierarchy to point to the last version of \Apfa;
\item[\texttt{-m} or \texttt{--merge-remote-branches}
  \texttt{\emph{<to-prefix>}} \texttt{\emph{[<origin-prefix>]}}] merge all
  the \texttt{p4a} branch infrastructure into the
  \texttt{\emph{<to-prefix>}} branch architecture. If the
  \texttt{\emph{<to-prefix>}} branch infrastructure does not exist, it is
  created from the \texttt{\emph{<origin-prefix>}} branch infrastructure
  if provided, else from the \texttt{p4a} branch architecture;
\item[\texttt{-b} or \texttt{--branch-action} \texttt{\emph{args+}}] apply
  the \texttt{\emph{args+}} shell-script to a branch hierarchy, with the
  branch suffix available to the \texttt{\emph{args+}} script in the
  \verb|$suffix| variable;
\item[\texttt{-a} or \texttt{--add-remotes}] create the remotes pointing
  into \verb|$P4A_CRI_GIT_SVN| and on the \Apolylib{} \Agit;
\item[\texttt{-r} or \texttt{--root} \texttt{<\emph{directory}>}] to
  change the git repository to work on.
\end{description}

A typical example to have a \Apfa with the last \Apips version into a very
personal \verb|p4a-very-personal| branch infrastructure:
\begin{verbatim}
p4a_git --update-git-svn
p4a_git --fetch-remote-git
p4a_git --pull-remote-git
\end{verbatim}
Then you have all \Apfa into the \verb|p4a| branch infrastructure.

If you want to begin from this \texttt{p4a} your own branch infrastructure
\verb|p4a-very-personal|, with \verb|p4a-very-personal-pips| for the
\Apips, \verb|p4a-very-personal-polylib| for the \Apolylib and so on,
attached to the main \verb|p4a|-prefixed branch infrastructure, you have
to do a:
\begin{verbatim}
p4a_git --merge-prefix-branches p4a-very-personal
\end{verbatim}

If you want to start from the \texttt{p4a-0.2-alpha}, use a
\begin{verbatim}
p4a_git --merge-prefix-branches p4a-very-personal p4a-0.2-alpha
\end{verbatim}

When you are happy with this version, you can push these branches for
sharing or merge them into the main \Apfa \texttt{p4a} with
\begin{verbatim}
p4a_git --branch-action git push origin p4a-very-personal\$suffix
\end{verbatim}

An example to set up all the tracking branches for version
\texttt{p4a-0.2-alpha} before you can use them:
\begin{verbatim}
p4a_git --branch-action git branch p4a-0.2-alpha\$suffix \
        remotes/origin/p4a-0.2-alpha\$suffix
\end{verbatim}


\subsection{PolyLib work-flow}
\label{sec:polylib-workflow}

The basic workflow for \Apolylib is to develop new features into the
original \Apolylib{} \Agit, to fetch it into the \Apfa{} \Agit and select what
feature we want to have into the \texttt{packages/polylib} of \Apfa.

The script \verb|p4a_git| is used to automate the management of the
workflow.

\verb|p4a_git --pull-remote-git| pulls the \Apolylib into the
\texttt{polylib} branch so that you can apply global modifications there
if needed and later \texttt{git merge} it into your working branch. In
this way global modifications are persistent and available to everybody.

If you want to directly manage the \Apolylib workflow, here are some
details about how it works.

Since the \Apolylib is already in a \Agit, the \texttt{polylib} is simply
a remote in the \Apfa{} \Agit.

So to import the latest \Apolylib development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch \Apolylib with:
\begin{verbatim}
git fetch ICPS/polylib
\end{verbatim}

You can then merge the feature you want with
\begin{verbatim}
git merge -s subtree remotes/polylib/master
\end{verbatim}
or from any tree identifier. The \texttt{-s subtree} is necessary since in
\Apfa the \Apolylib files are not at the top-level directory. This should
be done into the \texttt{polylib} branch if you want to be compatible with
the workflow chosen in \Apfa.


\subsection{PIPS work-flow}
\label{sec:pips-workflow}

The work-flow related to \Apips is quite more complex since we must
consolidate data from 5 different \Asvn repositories. The script
\verb|p4a_git| is used to automate the management of this workflow too,
but we describes it further here if you want to dig into it.

The basic \Apips work-flow is to develop into the 5 original \Apips{}
\Asvn repositories at MINES ParisTech/\Acri and to import the selected
developments into the \Apfa{} \Agit.

For this, we use 5 \Agit repositories that are gateways with these \Asvn
repositories. For technical reasons, it is better that this kind of subtle
gateway exists in only one place and this is currently done on the laptop
of Ronan \textsc{Keryell}. Then these 5 gateways are used as remotes into
the \Apfa{} \Agit. To synchronize these gateways to the latest version of
the \Apips{} \Asvn repositories, use a \verb|pips_git| in the directory
owning these \Agit-\Asvn repositories.

But since we have then a \Agit interface of the original \Apips{} \Asvn
repositories and \Agit is quite more powerful than \Asvn, some people may
want to develop into \Apips with \Agit by using these gateways. For
example they may want to develop with common branches easily and when they
are right with them push them back into the \Apips{} \Asvn trunk. To have
a public interface for them, these \Agit gateways are pushed to public
\Agit repository programmers can play with. Regularly these public
gateways are synchronized manually with the \Apips{} \Asvn. Nevertheless,
\Asvn may not be credited with the right owner of the commit but with the
one running the gateway, which is not fair. So the preferred way is to
directly develop in the original \Apips \Asvn repository (eventually with
her own \Agit-\Asvn gateway).

The 5 public gateway \Agit repositories are also defined as 5 remotes into
the \Apfa{} \Agit:
\begin{description}
\item[\texttt{remotes/CRI/linear}]
\item[\texttt{remotes/CRI/newgen}]
\item[\texttt{remotes/CRI/nlpmake}]
\item[\texttt{remotes/CRI/pips}]
\item[\texttt{remotes/CRI/validation}]
\end{description}

These remote repositories are merged into \Apfa in the following
respective directories:
\begin{description}
\item[\texttt{packages/PIPS/linear}]
\item[\texttt{packages/PIPS/newgen}]
\item[\texttt{packages/PIPS/nlpmake}]
\item[\texttt{packages/PIPS/pips}]
\item[\texttt{packages/PIPS/validation}]
\end{description}

To import the latest \Apips development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch the repositories you want
with:
\begin{verbatim}
git fetch CRI/linear
git fetch CRI/newgen
git fetch CRI/nlpmake
git fetch CRI/pips
git fetch CRI/validation
\end{verbatim}
These commands are also done by a \verb|p4a_fetch_all| that fetches also the
\Apolylib part.

You can then merge the feature you want with a \texttt{git merge -s
  subtree} from \texttt{remotes/CRI/.../master} as:
\begin{verbatim}
git merge -strategy=subtree remotes/CRI/linear/master
git merge -strategy=subtree remotes/CRI/newgen/master
git merge -strategy=subtree remotes/CRI/nlpmake/master
git merge -strategy=subtree remotes/CRI/pips/master
git merge -strategy=subtree remotes/CRI/validation/master
\end{verbatim}
or from any tree identifier to do more precise version selection. The
\texttt{-s subtree} is necessary since in \Apfa the \Apips files are not
at the top-level directory and you do not want them to appear at the
top-level directory.

To pull everything at one for testing, this is done with the
\verb|p4a_git| script described in \S~\ref{sec:p4a_git-script-deal}. Do
not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback.


\subsection{PIPS-GFC extension workflow}
\label{sec:pips-gfc-workflow}

This part is into the \texttt{package/pips-gfc} directory. It contains
plain \Agcc core and Fortran 4.4.1 distribution, pointed by the branch
\texttt{gcc-4.4.1}

The development of \Apipsgfc should be done in the branch
\texttt{pips-gfc-4.4.1} and this branch should be merged with the
branch \texttt{gcc-4.4.1} into a branch \texttt{pips-gfc+gcc-4.4.1} with a
more global name \texttt{pips-gfc+gcc} tracking which version is to be
merged into the global \texttt{master} branch.

So in \texttt{pips-gfc-4.4.1} there should be only files different from
the \Agcc distribution. In this way, if we want to have more subtle
construction methods, later, it will be clearer how to get the real
content.

There is the same variation in branches for version 4.4.2.

So to develop and test the \Apipsgfc extension, you get into for example
\texttt{pips-gfc-4.4.1} with
\begin{verbatim}
git checkout pips-gfc-4.4.1
\end{verbatim}
and develop your code in this branch.

To test, you commit and change to the \texttt{pips-gfc+gcc-4.4.1} branch with
\begin{verbatim}
git checkout pips-gfc+gcc-4.4.1
\end{verbatim}
where you merge with a
\begin{verbatim}
git merge pips-gfc-4.4.1
\end{verbatim}
and compile. If you are happy, you commit or you revert and then go back
into branch \texttt{pips-gfc-4.4.1}.

If you want to avoid spoiling the branches \texttt{pips-gfc-4.4.1} and
\texttt{pips-gfc+gcc-4.4.1}, you can create sub-branches of them, commit in
them and merge this work in the former one back (with the \verb|--slashed|
if you want to be modest about your gory hesitations \smiley{} and delete
these branches).


\subsection{Setting and running the infrastructure up}
\label{sec:setup}

The installation has been tested on Ubuntu/Linux 9.10 and you need to have
at least these packages installed:
\marginpar{À compléter par Mickael \& Claire !}


There are scripts to ease the developer and user life.


\subsubsection{Scripts for an everyday work}
\label{sec:an-everyday-work}

\begin{itemize}
\item To automate the \Apfa workflow and deal with \texttt{git} stuff, the
  \verb|p4a_git| is available, as described in
  \S~\ref{sec:p4a_git-script-deal};
\item \verb|p4a_setup| is used to compile all the \Apfa infrastructure and
  setting up many things. It should be used at least for the first
  compilation;
\item \verb|p4a_validate| is used to leverage the \Apips validation.
\end{itemize}


\subsubsection{Scripts for debugging}
\label{sec:scripts-debugging}

\begin{itemize}
\item \verb|p4a_valgrind| launch a command with Valgrind with a memory
  checker in paranoid mode, mainly with the options described in the
  \Apips development guide.
\end{itemize}


\subsubsection{Scripts used to setup the infrastructure}
\label{sec:scripts-used-setup}


Some scripts used to setup the infrastructure. They have been used to
bootstrap the \Apfa infrastructure and should not be used by ordinary
people but contain some interesting hacks that could be usefull for other
projects or if things go really wrong. There are located in
\texttt{src/dev}, that should be used in this order:
\begin{itemize}
\item \verb/p4a_create_CRI_git_svn/ is used once to create the \Apips
  \Asvn-\Agit gateways. This script is here to show how it can be done but
  also to keep track of the exact parameters used to create them in the
  case we loose them and want to recreate them with exactly with the same
  identifiers (that depends from the creation parameters);
\item \verb/p4a_import_external_gits/ imports all the external \Agit
  repositories into the \Apfa{} \Agit repository. It should be used only
  once but are included as example for other projects or to help adding
  other repositories later;
\item \verb/p4a_apply_pips_patches/ is used to patch the original \Apips
  files to fit the \Apfa architecture. It should be used only once, after
  external \Agit import. It is no longer used since we switch to the
  \Aautotools version of \Apips;
\end{itemize}


\section{Examples and demos}
\label{sec:examples-demos}

The \texttt{examples} directory comes with examples to show some aspects
of \Apfa. Of course there are far more examples in the validation of \Apfa
(\S~\ref{sec:validation}) but it is often less pedagogical.


\section{Validation}
\label{sec:validation}


Validation of \Apfa is done inside the \texttt{validation} directory with
\texttt{make validate}.

But right now it is still mostly done in the
\texttt{package/PIPS/validation} directory.

To ease interacting with the validation, the \verb|p4a_validate| is a
script that adds the concept of validation classes to the \Apips
validation. A class is a set of validation cases. For example we may have
a class for \texttt{ALL} the validation, the \texttt{CHANGED},
\texttt{FAILED}, \texttt{PASS}, \verb|PREVIOUS_ALL|,
\verb|PREVIOUS_CHANGED|, \verb|PREVIOUS_FAILED|, \verb|PREVIOUS_PASS|,
whatever user class and it is possible to make actions with them, combine
them with operators (unions, intersections...).

Some other classes can be defined directly in the validation directories
with \texttt{.vclass} line-oriented regexp filter lines or
generic Python code \texttt{.vclasspy}.

\verb|p4a_validate| has a small script interface, but the power user
should use the Python classes directly, for example from \texttt{iPython}
to add interactivity.

The first use in \Apfa is to select from \Apips only the test cases that
pass the validation (futuristic cases are interesting for \Apips but from
least interest for \Apfa...), defining smaller validation classes such as
a \Amat (Minimal Acceptance Test).


\section{Branches}
\label{sec:branches}

Since there are restrictions on the use of \texttt{/} in branch names, we
prefer to use \texttt{-} to add hierarchy.

To ease the developments and the organization, there are some already
defined branches:
\begin{description}
\item[\texttt{gcc-4.4.1}] is the original \Agcc 4.4.1 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{gcc-4.4.2}] is the original \Agcc 4.4.2 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{initial}] points to the initial commit of the \Apfa
  repository. It is useful to add stuff directly add the root of the
  repository to set the branch for the different packages. It should not
  be useful for normal people;
\item[\texttt{p4a-\emph{numerical}}] a branch corresponding to a given version
  snapshot;
\item[\texttt{p4a-\emph{numerical}-alpha}] a branch corresponding to an alpha
  version of a given version snapshot;
\item[\texttt{p4a-\emph{numerical}-beta}] a branch corresponding to an beta
  version of a given version snapshot;
\item[\texttt{p4a}] is the branch to get the full latest \Apfa version
  with all the different components, that is the merge of the branches
  \texttt{p4a-own} and \texttt{p4a-packages};
\item[\texttt{p4a-linear}] points to the import of \Apips \texttt{linear}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/linear} and used to merge from when you want to use
  the last version from \texttt{linear};
\item[\texttt{p4a-newgen}] points to the import of \Apips \texttt{newgen}
  part. So this branch should contain only the files from
  \texttt{package/PIPS/newgen};
\item[\texttt{p4a-nlpmake}] points to the import of \Apips \texttt{nlpmake}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/nlpmake};
\item[\texttt{p4a-own}] points to the last development of the \Apfa own files,
  without packages, etc;
\item[\texttt{p4a-packages}] points to the last merge of all the \Apfa
  package components;
\item[\texttt{p4a-pips}] points to the import of \Apips \texttt{pips}
  par. Thus this branch should contain only the files from
  \texttt{package/PIPS/pips} and used to merge from when you want to use
  the last version from \texttt{pips};
\item[\texttt{p4a-polylib}] points to the import of \Apips \texttt{polylib}
  par. Thus this branch should contain only the files from
  \texttt{package/polylib} and used to merge from when you want to use
  the last version from \texttt{polylib};
\item[\texttt{p4a-validation}] points to the import of \Apips
  \texttt{validation} part, with only files into
  \texttt{package/PIPS/validation};
\item[\texttt{pips-gfc+gcc}] points to a working \Apipsgfc implementation
  of the Fortran 95 extension for \Apips in \texttt{package/pips-gfc};
\item[\texttt{pips-gfc-4.4.1}] points to the original developments of
  Raphaël in \Agcc in \texttt{package/pips-gfc}.
\end{description}


Of course, for a better tractability, there are also branches that point
to specific versions of conceptual branches such as
\texttt{p4a-0.2-alpha-nlpmake}, \texttt{p4a-own-0.1} or
\texttt{p4a-packages-0.2-beta}.


\section{Making releases}
\label{sec:releases}

After validating, a release is done by making some branch at a given state
a tag.


\end{document}


%%% Local Variables: 
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

